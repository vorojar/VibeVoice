<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qwen3-TTS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'cream': '#FAF8F5',
                        'cream-dark': '#F5F0E8',
                        'warm-gray': '#E8E4DD',
                        'charcoal': '#2D3748',
                        'accent': '#E07A5F',
                        'accent-dark': '#C96A52',
                        'text-primary': '#2D3748',
                        'text-secondary': '#4A5568',
                        'text-muted': '#718096',
                        'border-color': '#E2DED6',
                    }
                }
            }
        }
    </script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: #FAF8F5;
            color: #2D3748;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }
        .scrollbar-thin::-webkit-scrollbar { width: 6px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: #D4CFC6; border-radius: 3px; }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #B8B2A7; }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: #4A5568;
        }
        .nav-item:hover { background: #F5F0E8; color: #2D3748; }
        .nav-item.active { background: #E07A5F; color: white; }

        .voice-card {
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid #E2DED6;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }
        .voice-card:hover { border-color: #E07A5F; background: #FDF8F6; }
        .voice-card.selected { border-color: #E07A5F; background: #FDF8F6; box-shadow: 0 0 0 2px rgba(224, 122, 95, 0.2); }

        .btn-primary {
            background: #E07A5F;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .btn-primary:hover { background: #C96A52; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

        .input-field {
            width: 100%;
            padding: 10px 14px;
            background: white;
            border: 1px solid #E2DED6;
            border-radius: 8px;
            color: #2D3748;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        .input-field:focus { outline: none; border-color: #E07A5F; }
        .input-field::placeholder { color: #A0AEC0; }

        textarea.input-field {
            resize: none;
            line-height: 1.8;
            font-size: 16px;
        }

        /* å¥å­è¿›åº¦æ ·å¼ */
        .sentence-pending {
            color: #2D3748;
        }
        .sentence-current {
            color: #E07A5F;
            background: #FEF3E2;
            padding: 2px 4px;
            border-radius: 4px;
        }
        .sentence-done {
            color: #A0AEC0;
        }

        /* æ’­æ”¾é«˜äº® */
        .sentence-editor-item.playing {
            background: #FEF3E2;
            border-color: #E07A5F;
        }
        .sentence-editor-item.played:not(.selected) {
            opacity: 0.5;
        }

        select.input-field {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%234A5568' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 40px;
        }

        .audio-player {
            background: white;
            border-radius: 12px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            border: 1px solid #E2DED6;
        }

        .play-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #E07A5F;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .play-btn:hover { background: #C96A52; transform: scale(1.05); }
        .play-btn svg { fill: white; }

        .waveform-container {
            height: 48px;
            border-radius: 8px;
            overflow: hidden;
            background: #FAF8F5;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .fade-in {
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* å¥å­ç¼–è¾‘è§†å›¾ */
        .sentence-editor-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .sentence-editor-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
            border: 1px solid transparent;
        }
        .sentence-editor-item:hover {
            background: #F5F0E8;
        }
        .sentence-editor-item.selected {
            background: #FEF3E2;
            border-color: #E07A5F;
        }
        .sentence-editor-item.regenerating {
            pointer-events: none;
        }
        .sentence-editor-item.regenerating .sentence-editor-text {
            opacity: 0.5;
        }
        .sentence-editor-index {
            color: #A0AEC0;
            font-size: 12px;
            min-width: 20px;
            text-align: right;
            padding-top: 2px;
            flex-shrink: 0;
        }
        .sentence-editor-text {
            line-height: 1.6;
            min-height: 1.6em;
            outline: none;
            display: block;
        }
        .sentence-instruct-tag {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: #A0AEC0;
            cursor: pointer;
            margin-top: 1px;
        }
        .sentence-instruct-tag:hover { color: #E07A5F; }
        .sentence-instruct-edit { opacity: 0; transition: opacity 0.15s; }
        .sentence-instruct-tag:hover .sentence-instruct-edit { opacity: 1; }
        .sentence-instruct-value { font-style: italic; }
        .sentence-instruct-input {
            flex: 1;
            font-size: 11px;
            border: 1px solid #E07A5F;
            border-radius: 3px;
            padding: 1px 4px;
            outline: none;
            background: white;
            color: #2D3748;
        }
        .sentence-editor-text[contenteditable="true"] {
            background: white;
            border: 1px solid #E07A5F;
            border-radius: 4px;
            padding: 2px 6px;
        }
        .sentence-editor-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .sentence-editor-item.selected .sentence-editor-actions,
        .sentence-editor-item:hover .sentence-editor-actions {
            opacity: 1;
        }
        .sentence-regen-btn {
            padding: 2px 8px;
            font-size: 12px;
            border-radius: 4px;
            border: 1px solid #E07A5F;
            color: #E07A5F;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }
        .sentence-regen-btn:hover {
            background: #E07A5F;
            color: white;
        }
        .sentence-play-btn, .sentence-del-btn {
            padding: 2px 6px;
            font-size: 12px;
            border-radius: 4px;
            border: 1px solid #E2DED6;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
            line-height: 1;
        }
        .sentence-play-btn:hover { border-color: #E07A5F; color: #E07A5F; }
        .sentence-play-btn.playing-now { border-color: #E07A5F; color: #E07A5F; background: #FEF3E2; }
        .sentence-del-btn:hover { border-color: #e53e3e; color: #e53e3e; }
        .sentence-insert-row {
            height: 4px;
            position: relative;
            transition: height 0.15s;
        }
        .sentence-insert-row:hover {
            height: 20px;
        }
        .sentence-insert-btn {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border: none;
            background: #F5F0E8;
            color: #CBD5E0;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            padding: 0 8px;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.15s, color 0.15s;
            z-index: 1;
        }
        .sentence-insert-row:hover .sentence-insert-btn {
            opacity: 1;
        }
        .sentence-insert-btn:hover { color: #E07A5F; }
        .sentence-insert-form {
            padding: 8px 10px;
            background: #FEF3E2;
            border: 1px dashed #E07A5F;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .sentence-insert-form input[type="text"] {
            width: 100%;
            font-size: 13px;
            padding: 4px 8px;
            border: 1px solid #E2DED6;
            border-radius: 4px;
            outline: none;
            background: white;
            color: #2D3748;
        }
        .sentence-insert-form input[type="text"]:focus {
            border-color: #E07A5F;
        }
        .sentence-insert-form-actions {
            display: flex;
            align-items: center;
            gap: 6px;
            justify-content: flex-end;
        }
        .sentence-insert-form-actions button {
            font-size: 12px;
            padding: 2px 10px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #E2DED6;
            background: white;
            color: #4A5568;
            transition: all 0.15s;
        }
        .sentence-insert-form-actions .confirm-btn {
            background: #E07A5F;
            border-color: #E07A5F;
            color: white;
        }
        .sentence-insert-form-actions .confirm-btn:hover { background: #C96A52; }
        .sentence-insert-form-actions button:not(.confirm-btn):hover { background: #F5F0E8; }
        .sentence-inserting-placeholder {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: #FEF3E2;
            border: 1px dashed #E07A5F;
            border-radius: 6px;
            color: #E07A5F;
            font-size: 13px;
            animation: insertPulse 1.5s ease-in-out infinite;
        }
        @keyframes insertPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .sentence-editor-list.inserting > li:not(.inserting-row) {
            pointer-events: none;
            opacity: 0.5;
        }

        /* å½•éŸ³åŠ¨ç”» */
        .recording-indicator {
            width: 12px;
            height: 12px;
            background: #ef4444;
            border-radius: 50%;
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
    </style>
</head>
<body>
    <div class="h-screen flex flex-col">
        <!-- é¡¶éƒ¨æ  -->
        <header class="h-14 bg-white border-b border-warm-gray flex items-center justify-between px-4 flex-shrink-0">
            <div class="flex items-center gap-3">
                <span class="text-xl">ğŸ™ï¸</span>
                <span class="font-bold text-lg text-charcoal">Qwen3-TTS</span>
            </div>
            <div class="flex items-center gap-2">
                <button onclick="toggleLanguage()" class="px-3 py-1.5 text-sm text-charcoal/60 hover:text-charcoal transition-colors">
                    <span id="lang-toggle">EN</span>
                </button>
                <button onclick="showPage('api')" class="px-3 py-1.5 text-sm text-charcoal/60 hover:text-charcoal transition-colors" data-i18n="nav.api">
                    API æ–‡æ¡£
                </button>
            </div>
        </header>

        <!-- ä¸»å†…å®¹åŒº -->
        <div class="flex-1 flex overflow-hidden">
            <!-- å·¦ä¾§è¾¹æ  -->
            <aside class="w-56 bg-cream-dark border-r border-warm-gray flex flex-col flex-shrink-0">
                <!-- å¯¼èˆªèœå• -->
                <nav class="p-3 space-y-1">
                    <div class="nav-item active" onclick="switchMode('preset')" data-mode="preset">
                        <span>ğŸ¤</span>
                        <span data-i18n="nav.preset">é¢„è®¾è¯´è¯äºº</span>
                    </div>
                    <div class="nav-item" onclick="switchMode('clone')" data-mode="clone">
                        <span>ğŸ­</span>
                        <span data-i18n="nav.clone">è¯­éŸ³å…‹éš†</span>
                    </div>
                    <div class="nav-item" onclick="switchMode('design')" data-mode="design">
                        <span>âœ¨</span>
                        <span data-i18n="nav.design">å£°éŸ³è®¾è®¡</span>
                    </div>
                </nav>

                <!-- å£°éŸ³åº“ (ä»…å…‹éš†æ¨¡å¼æ˜¾ç¤º) -->
                <div id="voice-library-section" class="hidden flex-1 flex flex-col border-t border-warm-gray mt-2">
                    <div class="p-3 flex items-center justify-between">
                        <span class="text-sm font-medium text-charcoal/70" data-i18n="clone.voiceLibrary">å£°éŸ³åº“</span>
                        <button onclick="loadSavedVoices()" class="text-charcoal/40 hover:text-charcoal text-sm">â†»</button>
                    </div>
                    <div id="voice-list" class="flex-1 overflow-y-auto scrollbar-thin px-3 pb-3 space-y-2">
                        <!-- å£°éŸ³åˆ—è¡¨ -->
                    </div>
                </div>

                <!-- åº•éƒ¨ç‰ˆæœ¬ä¿¡æ¯ -->
                <div class="mt-auto p-3 border-t border-warm-gray text-xs text-charcoal/40">
                    Qwen3-TTS v1.0
                </div>
            </aside>

            <!-- ä¸­é—´å†…å®¹åŒº -->
            <main class="flex-1 flex flex-col bg-cream overflow-hidden">
                <!-- æ–‡æœ¬è¾“å…¥åŒº -->
                <div class="flex-1 p-6 flex flex-col min-h-0">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-lg font-semibold text-charcoal" data-i18n="main.title">æ–‡å­—è½¬è¯­éŸ³</h2>
                        <span id="char-count" class="text-sm text-charcoal/50">0 <span data-i18n="stats.chars">å­—</span></span>
                    </div>
                    <textarea
                        id="text-input"
                        class="input-field flex-1"
                        data-i18n-placeholder="main.placeholder"
                        placeholder="åœ¨æ­¤è¾“å…¥è¦è½¬æ¢çš„æ–‡æœ¬..."
                        oninput="updateCharCount()"
                    ></textarea>
                    <!-- ç”Ÿæˆè¿›åº¦è§†å›¾ (ç”Ÿæˆæ—¶æ˜¾ç¤º) -->
                    <div id="progress-view" class="hidden input-field flex-1 text-base" style="line-height:1.8;min-height:0"></div>
                    <!-- è¿”å›å¥å­è§†å›¾æŒ‰é’® -->
                    <div id="sentence-view-hint" class="hidden mt-2">
                        <button onclick="showSentenceEditorView()" class="text-sm text-accent hover:text-accent-dark transition-colors" style="background:none;border:none;cursor:pointer">
                            â† <span data-i18n="btn.sentenceView">è¿”å›å¥å­è§†å›¾</span>
                        </button>
                    </div>

                    <!-- æ“ä½œæ  -->
                    <div class="flex items-center justify-between mt-4">
                        <div id="status-message" class="text-sm text-charcoal/60"></div>
                        <button id="generate-btn" onclick="generate()" class="btn-primary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            <span data-i18n="btn.generate">ç”Ÿæˆè¯­éŸ³</span>
                        </button>
                        <!-- å¥å­è§†å›¾å·¥å…·æ ï¼ˆå¥å­è§†å›¾æ—¶æ›¿ä»£ç”ŸæˆæŒ‰é’®ï¼‰ -->
                        <div id="sentence-toolbar" class="hidden" style="display:none;align-items:center;gap:12px;width:100%">
                            <button onclick="exitSentenceEditorView()" class="text-sm text-accent hover:text-accent-dark transition-colors" style="background:none;border:none;cursor:pointer">
                                â† <span data-i18n="btn.backToText">è¿”å›ç¼–è¾‘è§†å›¾</span>
                            </button>
                            <div style="margin-left:auto;display:flex;align-items:center;gap:6px;font-size:12px;color:#718096">
                                <span id="st-pace-label"></span>
                                <span id="st-pace-value" style="min-width:28px;text-align:center;font-variant-numeric:tabular-nums"></span>
                                <input type="range" id="st-pace-range" min="0" max="2" step="0.1"
                                    style="width:100px;accent-color:#E07A5F"
                                    oninput="pausePaceMultiplier=parseFloat(this.value); document.getElementById('st-pace-value').textContent=this.value==='0'?t('label.paceOff'):parseFloat(this.value).toFixed(1)+'x'; rebuildAudioAndSubtitles()"
                                    onchange="saveSession()">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- éŸ³é¢‘æ’­æ”¾å™¨ -->
                <div id="player-section" class="hidden border-t border-warm-gray p-4 bg-cream-dark">
                    <div class="audio-player">
                        <button id="play-btn" class="play-btn" onclick="togglePlay()">
                            <svg id="play-icon" width="20" height="20" viewBox="0 0 24 24">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                        </button>
                        <div class="flex-1">
                            <div id="waveform" class="waveform-container"></div>
                            <div class="flex justify-between mt-1 text-xs text-charcoal/50">
                                <span id="current-time">0:00</span>
                                <span id="duration">0:00</span>
                            </div>
                        </div>
                        <div id="stats-display" class="text-right text-sm">
                            <div class="text-charcoal font-medium" id="stats-chars">-</div>
                            <div class="text-charcoal/50 text-xs" id="stats-speed">-</div>
                        </div>
                        <div class="relative ml-4">
                            <button id="download-btn" onclick="toggleDownloadMenu()" class="p-3 bg-accent hover:bg-accent-dark text-white rounded-lg transition-colors flex items-center gap-1" title="ä¸‹è½½">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="7 10 12 15 17 10"></polyline>
                                    <line x1="12" y1="15" x2="12" y2="3"></line>
                                </svg>
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M6 9l6 6 6-6"></path>
                                </svg>
                            </button>
                            <div id="download-menu" class="hidden absolute right-0 bottom-full mb-2 bg-white rounded-lg shadow-lg border border-warm-gray overflow-hidden z-10">
                                <button onclick="downloadAudio('wav')" class="w-full px-4 py-2 text-left text-sm hover:bg-cream font-medium">WAV</button>
                                <button onclick="downloadAudio('mp3')" class="w-full px-4 py-2 text-left text-sm hover:bg-cream font-medium border-t border-warm-gray">MP3</button>
                                <button onclick="downloadSubtitle('srt')" class="w-full px-4 py-2 text-left text-sm hover:bg-cream font-medium border-t border-warm-gray">SRT</button>
                                <button onclick="downloadSubtitle('vtt')" class="w-full px-4 py-2 text-left text-sm hover:bg-cream font-medium border-t border-warm-gray">VTT</button>
                            </div>
                        </div>
                    </div>
                    <audio id="audio-element" class="hidden"></audio>
                </div>
            </main>

            <!-- å³ä¾§é…ç½®é¢æ¿ -->
            <aside class="w-72 bg-white border-l border-warm-gray flex flex-col flex-shrink-0 overflow-y-auto scrollbar-thin">
                <div class="p-4 border-b border-warm-gray">
                    <h3 class="font-semibold text-charcoal" data-i18n="config.title">é…ç½®</h3>
                </div>

                <div class="p-4 space-y-5">
                    <!-- é¢„è®¾è¯´è¯äººé…ç½® -->
                    <div id="config-preset" class="space-y-4">
                        <div>
                            <label class="block text-sm text-charcoal/70 mb-2" data-i18n="config.speaker">è¯´è¯äºº</label>
                            <select id="speaker" class="input-field">
                                <option value="vivian">Vivian (ä¸­æ–‡å¥³)</option>
                                <option value="uncle_fu">Uncle Fu (ä¸­æ–‡ç”·)</option>
                                <option value="aiden">Aiden (è‹±æ–‡ç”·)</option>
                                <option value="serena">Serena (è‹±æ–‡å¥³)</option>
                                <option value="ono_anna">Ono Anna (æ—¥è¯­å¥³)</option>
                                <option value="sohee">Sohee (éŸ©è¯­å¥³)</option>
                                <option value="dylan">Dylan (ç”·)</option>
                                <option value="eric">Eric (ç”·)</option>
                                <option value="ryan">Ryan (ç”·)</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm text-charcoal/70 mb-2" data-i18n="config.language">è¯­è¨€</label>
                            <select id="language-preset" class="input-field">
                                <option value="Chinese">ä¸­æ–‡</option>
                                <option value="English">English</option>
                                <option value="Japanese">æ—¥æœ¬èª</option>
                                <option value="Korean">í•œêµ­ì–´</option>
                                <option value="German">Deutsch</option>
                                <option value="French">FranÃ§ais</option>
                                <option value="Russian">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                                <option value="Portuguese">PortuguÃªs</option>
                                <option value="Spanish">EspaÃ±ol</option>
                                <option value="Italian">Italiano</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm text-charcoal/70 mb-2" data-i18n="config.instruct">æƒ…æ„ŸæŒ‡ä»¤ <span class="text-charcoal/50">(å¯é€‰)</span></label>
                            <input type="text" id="instruct" class="input-field" data-i18n-placeholder="config.instructPlaceholder" placeholder="å¦‚ï¼šç”¨å¼€å¿ƒçš„è¯­æ°”è¯´">
                        </div>
                    </div>

                    <!-- è¯­éŸ³å…‹éš†é…ç½® -->
                    <div id="config-clone" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm text-charcoal/70 mb-2" data-i18n="config.language">è¯­è¨€</label>
                            <select id="language-clone" class="input-field">
                                <option value="Chinese">ä¸­æ–‡</option>
                                <option value="English">English</option>
                                <option value="Japanese">æ—¥æœ¬èª</option>
                                <option value="Korean">í•œêµ­ì–´</option>
                                <option value="German">Deutsch</option>
                                <option value="French">FranÃ§ais</option>
                                <option value="Russian">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                                <option value="Portuguese">PortuguÃªs</option>
                                <option value="Spanish">EspaÃ±ol</option>
                                <option value="Italian">Italiano</option>
                            </select>
                        </div>

                        <!-- éŸ³é¢‘æ¥æº -->
                        <div>
                            <label class="block text-sm text-charcoal/70 mb-2" data-i18n="config.refAudio">å‚è€ƒéŸ³é¢‘</label>
                            <div class="space-y-2">
                                <!-- å½•éŸ³æŒ‰é’® -->
                                <button id="record-btn" onclick="toggleRecording()" class="w-full flex items-center justify-center gap-2 py-3 bg-cream-dark border border-warm-gray rounded-lg hover:bg-warm-gray transition-colors">
                                    <span id="record-icon">ğŸ™ï¸</span>
                                    <span id="record-text" data-i18n="btn.record">å½•éŸ³</span>
                                    <span id="record-timer" class="hidden text-accent font-mono">00:00</span>
                                </button>
                                <!-- ä¸Šä¼ æŒ‰é’® -->
                                <label class="w-full flex items-center justify-center gap-2 py-3 bg-cream-dark border border-warm-gray rounded-lg hover:bg-warm-gray transition-colors cursor-pointer">
                                    <span>ğŸ“</span>
                                    <span data-i18n="btn.upload">ä¸Šä¼ æ–‡ä»¶</span>
                                    <input type="file" id="audio-file" accept="audio/*" class="hidden" onchange="handleFileSelect(this)">
                                </label>
                            </div>
                            <!-- éŸ³é¢‘é¢„è§ˆ -->
                            <div id="audio-preview-section" class="hidden mt-3 p-3 bg-cream-dark rounded-lg">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm text-charcoal/70" data-i18n="config.preview">éŸ³é¢‘é¢„è§ˆ</span>
                                    <button onclick="clearAudio()" class="text-charcoal/50 hover:text-red-600 text-sm">âœ•</button>
                                </div>
                                <audio id="audio-preview" controls class="w-full mt-2 h-8"></audio>
                            </div>
                        </div>

                        <div>
                            <label class="block text-sm text-charcoal/70 mb-2">
                                <span data-i18n="config.refText">å‚è€ƒæ–‡æœ¬</span>
                                <span class="text-charcoal/50" data-i18n="config.refTextHint">(å¯é€‰ï¼Œæé«˜è´¨é‡)</span>
                            </label>
                            <textarea id="ref-text" class="input-field h-20" data-i18n-placeholder="config.refTextPlaceholder" placeholder="å‚è€ƒéŸ³é¢‘çš„æ–‡å­—å†…å®¹"></textarea>
                        </div>

                        <!-- ä¿å­˜å£°éŸ³ -->
                        <div id="save-voice-section" class="hidden pt-4 border-t border-warm-gray">
                            <label class="block text-sm text-charcoal/70 mb-2" data-i18n="config.saveName">ä¿å­˜åˆ°å£°éŸ³åº“</label>
                            <div class="flex gap-2">
                                <input type="text" id="voice-name" class="input-field flex-1" data-i18n-placeholder="config.saveNamePlaceholder" placeholder="å£°éŸ³åç§°">
                                <button onclick="saveVoice()" class="px-4 py-2 bg-cream-dark border border-warm-gray rounded-lg hover:bg-warm-gray transition-colors text-sm" data-i18n="btn.save">ä¿å­˜</button>
                            </div>
                        </div>
                    </div>

                    <!-- å£°éŸ³è®¾è®¡é…ç½® -->
                    <div id="config-design" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm text-charcoal/70 mb-2" data-i18n="config.language">è¯­è¨€</label>
                            <select id="language-design" class="input-field">
                                <option value="Chinese">ä¸­æ–‡</option>
                                <option value="English">English</option>
                                <option value="Japanese">æ—¥æœ¬èª</option>
                                <option value="Korean">í•œêµ­ì–´</option>
                                <option value="German">Deutsch</option>
                                <option value="French">FranÃ§ais</option>
                                <option value="Russian">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                                <option value="Portuguese">PortuguÃªs</option>
                                <option value="Spanish">EspaÃ±ol</option>
                                <option value="Italian">Italiano</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm text-charcoal/70 mb-2" data-i18n="config.voiceDesc">å£°éŸ³æè¿° <span class="text-red-500">*</span></label>
                            <textarea id="voice-desc" class="input-field h-24" data-i18n-placeholder="config.voiceDescPlaceholder" placeholder="æè¿°ä½ æƒ³è¦çš„å£°éŸ³ï¼Œå¦‚ï¼šä½æ²‰æ²™å“‘çš„ä¸­å¹´ç”·å£°ï¼Œè¯­é€Ÿè¾ƒæ…¢"></textarea>
                        </div>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <!-- API æ–‡æ¡£é¡µé¢ (è¦†ç›–å±‚) -->
    <div id="api-overlay" class="hidden fixed inset-0 bg-cream/95 z-50 overflow-y-auto">
        <div class="max-w-4xl mx-auto p-8">
            <div class="flex items-center justify-between mb-8">
                <h1 class="text-2xl font-bold text-charcoal" data-i18n="api.title">API æ–‡æ¡£</h1>
                <button onclick="showPage('main')" class="text-charcoal/50 hover:text-charcoal text-2xl">&times;</button>
            </div>

            <div class="space-y-6">
                <!-- é¢„è®¾è¯´è¯äºº API -->
                <div class="bg-white rounded-xl p-6 border border-warm-gray">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2 text-charcoal">
                        <span>ğŸ¤</span>
                        <span data-i18n="api.presetTTS">é¢„è®¾è¯´è¯äºº TTS</span>
                    </h3>
                    <div class="space-y-3">
                        <div class="flex items-center gap-2">
                            <span class="px-2 py-1 bg-green-100 text-green-700 text-xs font-medium rounded">GET</span>
                            <code class="text-sm">/tts</code>
                        </div>
                        <pre class="bg-charcoal rounded-lg p-4 overflow-x-auto text-sm text-green-400"><code>curl "http://localhost:8000/tts?text=ä½ å¥½ä¸–ç•Œ&speaker=vivian&language=Chinese" -o output.wav</code></pre>
                    </div>
                </div>

                <!-- è¯­éŸ³å…‹éš† API -->
                <div class="bg-white rounded-xl p-6 border border-warm-gray">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2 text-charcoal">
                        <span>ğŸ­</span>
                        <span data-i18n="api.cloneTTS">è¯­éŸ³å…‹éš†</span>
                    </h3>
                    <div class="space-y-3">
                        <div class="flex items-center gap-2">
                            <span class="px-2 py-1 bg-blue-100 text-blue-700 text-xs font-medium rounded">POST</span>
                            <code class="text-sm">/clone</code>
                        </div>
                        <pre class="bg-charcoal rounded-lg p-4 overflow-x-auto text-sm text-green-400"><code>curl -X POST "http://localhost:8000/clone" \
  -F "audio=@reference.wav" \
  -F "text=ä½ å¥½ä¸–ç•Œ" \
  -F "language=Chinese" \
  -o output.wav</code></pre>
                    </div>
                </div>

                <!-- å£°éŸ³è®¾è®¡ API -->
                <div class="bg-white rounded-xl p-6 border border-warm-gray">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2 text-charcoal">
                        <span>âœ¨</span>
                        <span data-i18n="api.designTTS">å£°éŸ³è®¾è®¡</span>
                    </h3>
                    <div class="space-y-3">
                        <div class="flex items-center gap-2">
                            <span class="px-2 py-1 bg-blue-100 text-blue-700 text-xs font-medium rounded">POST</span>
                            <code class="text-sm">/design</code>
                        </div>
                        <pre class="bg-charcoal rounded-lg p-4 overflow-x-auto text-sm text-green-400"><code>curl -X POST "http://localhost:8000/design" \
  -F "text=ä½ å¥½ä¸–ç•Œ" \
  -F "language=Chinese" \
  -F "instruct=ä½æ²‰æ²™å“‘çš„ä¸­å¹´ç”·å£°" \
  -o output.wav</code></pre>
                    </div>
                </div>

                <!-- å£°éŸ³åº“ API -->
                <div class="bg-white rounded-xl p-6 border border-warm-gray">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2 text-charcoal">
                        <span>ğŸ“š</span>
                        <span data-i18n="api.voiceLibrary">å£°éŸ³åº“ç®¡ç†</span>
                    </h3>
                    <div class="space-y-4">
                        <div>
                            <div class="flex items-center gap-2 mb-2">
                                <span class="px-2 py-1 bg-green-100 text-green-700 text-xs font-medium rounded">GET</span>
                                <code class="text-sm text-charcoal">/voices</code>
                                <span class="text-charcoal/50 text-sm">- è·å–å·²ä¿å­˜çš„å£°éŸ³åˆ—è¡¨</span>
                            </div>
                        </div>
                        <div>
                            <div class="flex items-center gap-2 mb-2">
                                <span class="px-2 py-1 bg-blue-100 text-blue-700 text-xs font-medium rounded">POST</span>
                                <code class="text-sm text-charcoal">/voices/save</code>
                                <span class="text-charcoal/50 text-sm">- ä¿å­˜å£°éŸ³</span>
                            </div>
                        </div>
                        <div>
                            <div class="flex items-center gap-2 mb-2">
                                <span class="px-2 py-1 bg-blue-100 text-blue-700 text-xs font-medium rounded">POST</span>
                                <code class="text-sm text-charcoal">/voices/{voice_id}/tts</code>
                                <span class="text-charcoal/50 text-sm">- ä½¿ç”¨å·²ä¿å­˜å£°éŸ³ç”Ÿæˆ</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== çŠ¶æ€ç®¡ç† =====
        let currentMode = 'preset'; // preset, clone, design
        let currentLang = 'zh';
        let selectedVoiceId = null;
        let savedVoices = [];

        // å½•éŸ³ç›¸å…³
        let mediaRecorder = null;
        let audioChunks = [];
        let recordedBlob = null;
        let selectedFile = null;
        let recordingStartTime = null;
        let timerInterval = null;

        // å•å¥é‡æ–°ç”Ÿæˆç›¸å…³
        let sentenceAudios = [];   // æ¯å¥éŸ³é¢‘ base64 æ•°ç»„
        let sentenceTexts = [];    // æ¯å¥æ–‡æœ¬æ•°ç»„
        let sentenceInstructs = []; // æ¯å¥æƒ…æ„ŸæŒ‡ä»¤ï¼ˆä»… preset æ¨¡å¼æœ‰æ„ä¹‰ï¼‰
        let lastGenerateParams = null; // {mode, speaker, language, instruct, voice_id, clone_prompt_id}
        let clonePromptId = null;  // clone æ¨¡å¼çš„ session ID

        // æ’¤é”€æ ˆ
        let undoStack = []; // [{index, audio, text}]

        // å•å¥è¯•å¬
        let sentencePreviewIndex = -1;

        // ç»Ÿè®¡æ•°æ®ï¼ˆæ•°å€¼ï¼Œè¯­è¨€æ— å…³ï¼‰
        let lastStatsData = null; // {char_count, sentence_count, elapsed, avg_per_char}

        function renderStats() {
            if (!lastStatsData) return;
            const s = lastStatsData;
            if (s.sentence_count != null) {
                document.getElementById('stats-chars').textContent = `${s.char_count} ${t('stats.chars')} Â· ${s.sentence_count} ${t('stats.sentences')} Â· ${s.elapsed}s`;
            } else {
                document.getElementById('stats-chars').textContent = `${s.char_count} ${t('stats.chars')} Â· ${s.elapsed}s`;
            }
            document.getElementById('stats-speed').textContent = `${s.avg_per_char}s/${t('stats.chars')}`;
        }

        // æ ¹æ®å½“å‰ sentenceTexts é‡ç®—ç»Ÿè®¡å¹¶æ›´æ–°æ˜¾ç¤º
        function refreshStatsFromSentences() {
            if (!lastStatsData || !sentenceTexts.length) return;
            const charCount = sentenceTexts.join('').length;
            lastStatsData.char_count = charCount;
            lastStatsData.sentence_count = sentenceTexts.length;
            renderStats();
            // åŒæ­¥å³ä¸Šè§’å­—æ•°
            document.getElementById('char-count').innerHTML = `${charCount} <span data-i18n="stats.chars">${t('stats.chars')}</span>`;
        }

        // å¥é—´åœé¡¿
        let pausePaceMultiplier = 1.0;
        let decodedPcmCache = []; // ç¼“å­˜è§£ç åçš„ PCMï¼Œé¿å…é‡å¤ atob

        // ===== ä¼šè¯æŒä¹…åŒ– (IndexedDB) =====
        const SESSION_DB = 'vibevoice_session';
        const SESSION_STORE = 'session';
        const SESSION_KEY = 'current';

        function openSessionDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(SESSION_DB, 1);
                req.onupgradeneeded = () => req.result.createObjectStore(SESSION_STORE);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function saveSession() {
            if (!sentenceAudios.length) return;
            try {
                const db = await openSessionDB();
                const tx = db.transaction(SESSION_STORE, 'readwrite');
                tx.objectStore(SESSION_STORE).put({
                    sentenceAudios,
                    sentenceTexts,
                    sentenceInstructs,
                    lastGenerateParams,
                    clonePromptId,
                    currentSubtitles,
                    pausePaceMultiplier,
                    inputText: sentenceTexts.length > 0 ? sentenceTexts.join('') : document.getElementById('text-input').value,
                    statsData: lastStatsData,
                    timestamp: Date.now(),
                }, SESSION_KEY);
                db.close();
            } catch (e) { console.warn('saveSession failed:', e); }
        }

        async function loadSession() {
            try {
                const db = await openSessionDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(SESSION_STORE, 'readonly');
                    const req = tx.objectStore(SESSION_STORE).get(SESSION_KEY);
                    req.onsuccess = () => { db.close(); resolve(req.result || null); };
                    req.onerror = () => { db.close(); resolve(null); };
                });
            } catch (e) { return null; }
        }

        async function clearSession() {
            try {
                const db = await openSessionDB();
                const tx = db.transaction(SESSION_STORE, 'readwrite');
                tx.objectStore(SESSION_STORE).delete(SESSION_KEY);
                db.close();
            } catch (e) {}
        }

        async function restoreSession() {
            const session = await loadSession();
            if (!session || !session.sentenceAudios || !session.sentenceAudios.length) return;
            // æ¢å¤çŠ¶æ€
            sentenceAudios = session.sentenceAudios;
            sentenceTexts = session.sentenceTexts;
            lastGenerateParams = session.lastGenerateParams;
            sentenceInstructs = session.sentenceInstructs || sentenceTexts.map(() => (lastGenerateParams?.instruct || ''));
            clonePromptId = session.clonePromptId;
            currentSubtitles = session.currentSubtitles;
            pausePaceMultiplier = session.pausePaceMultiplier ?? 1.0;
            decodedPcmCache = [];
            // æ¢å¤è¾“å…¥æ¡†
            if (session.inputText) {
                document.getElementById('text-input').value = session.inputText;
                updateCharCount();
            }
            // é‡å»ºéŸ³é¢‘
            const merged = mergeAllSentenceAudios();
            currentSubtitles = merged.subtitles;
            audioElement.src = URL.createObjectURL(merged.blob);
            loadWaveform();
            // æ¢å¤ stats æ˜¾ç¤º
            if (session.statsData) { lastStatsData = session.statsData; }
            refreshStatsFromSentences();
            // æ˜¾ç¤ºæ’­æ”¾å™¨å’Œå¥å­è§†å›¾
            document.getElementById('player-section').classList.remove('hidden');
            if (sentenceTexts.length > 1) {
                selectedSentenceIndex = -1;
                showSentenceEditorView();
            }
        }

        // éŸ³é¢‘æ’­æ”¾
        const audioElement = document.getElementById('audio-element');

        // wavesurfer æ³¢å½¢å¯è§†åŒ–
        let wavesurfer = null;
        let wsRegions = null;

        function initWavesurfer() {
            if (wavesurfer) return;
            wavesurfer = WaveSurfer.create({
                container: '#waveform',
                height: 48,
                waveColor: '#E8E4DD',
                progressColor: '#E07A5F',
                cursorColor: '#2D3748',
                cursorWidth: 2,
                barWidth: 2,
                barGap: 1,
                barRadius: 2,
                barMinHeight: 1,
                normalize: true,
                interact: true,
                media: audioElement,
            });
            wsRegions = wavesurfer.registerPlugin(WaveSurfer.Regions.create());
            wavesurfer.on('ready', () => {
                updateWaveformRegions();
            });
            wavesurfer.on('timeupdate', (currentTime) => {
                document.getElementById('current-time').textContent = formatTime(currentTime);
                updatePlaybackHighlight(currentTime);
            });
        }

        function loadWaveform() {
            if (!audioElement.src) return;
            if (!wavesurfer) initWavesurfer();
            wavesurfer.load(audioElement.src);
        }

        function updateWaveformRegions() {
            if (!wsRegions) return;
            wsRegions.clearRegions();
            if (!currentSubtitles || !currentSubtitles.length) return;
            currentSubtitles.forEach((sub, i) => {
                wsRegions.addRegion({
                    start: sub.start,
                    end: sub.end,
                    color: i % 2 === 0 ? 'rgba(224,122,95,0.15)' : 'rgba(224,122,95,0.05)',
                    drag: false,
                    resize: false,
                });
            });
        }

        // ===== å›½é™…åŒ– =====
        const i18n = {
            zh: {
                'nav.preset': 'é¢„è®¾è¯´è¯äºº',
                'nav.clone': 'è¯­éŸ³å…‹éš†',
                'nav.design': 'å£°éŸ³è®¾è®¡',
                'nav.api': 'API æ–‡æ¡£',
                'main.title': 'æ–‡å­—è½¬è¯­éŸ³',
                'main.placeholder': 'åœ¨æ­¤è¾“å…¥è¦è½¬æ¢çš„æ–‡æœ¬...',
                'config.title': 'é…ç½®',
                'config.speaker': 'è¯´è¯äºº',
                'config.language': 'è¯­è¨€',
                'config.instruct': 'æƒ…æ„ŸæŒ‡ä»¤',
                'config.instructPlaceholder': 'å¦‚ï¼šç”¨å¼€å¿ƒçš„è¯­æ°”è¯´',
                'config.refAudio': 'å‚è€ƒéŸ³é¢‘',
                'config.refText': 'å‚è€ƒæ–‡æœ¬',
                'config.refTextHint': '(å¯é€‰ï¼Œæé«˜è´¨é‡)',
                'config.refTextPlaceholder': 'å‚è€ƒéŸ³é¢‘çš„æ–‡å­—å†…å®¹',
                'config.preview': 'éŸ³é¢‘é¢„è§ˆ',
                'config.voiceDesc': 'å£°éŸ³æè¿°',
                'config.voiceDescPlaceholder': 'æè¿°ä½ æƒ³è¦çš„å£°éŸ³ï¼Œå¦‚ï¼šä½æ²‰æ²™å“‘çš„ä¸­å¹´ç”·å£°',
                'config.saveName': 'ä¿å­˜åˆ°å£°éŸ³åº“',
                'config.saveNamePlaceholder': 'å£°éŸ³åç§°',
                'clone.voiceLibrary': 'å£°éŸ³åº“',
                'btn.generate': 'ç”Ÿæˆè¯­éŸ³',
                'btn.record': 'å½•éŸ³',
                'btn.stopRecord': 'åœæ­¢',
                'btn.upload': 'ä¸Šä¼ æ–‡ä»¶',
                'btn.save': 'ä¿å­˜',
                'btn.stop': 'åœæ­¢',
                'stats.chars': 'å­—',
                'stats.sentences': 'å¥',
                'status.generating': 'ç”Ÿæˆä¸­...',
                'status.success': 'ç”ŸæˆæˆåŠŸ',
                'status.failed': 'ç”Ÿæˆå¤±è´¥',
                'status.stopped': 'å·²åœæ­¢',
                'status.enterText': 'è¯·è¾“å…¥æ–‡æœ¬',
                'status.needAudio': 'è¯·å½•éŸ³æˆ–ä¸Šä¼ å‚è€ƒéŸ³é¢‘',
                'status.needDesc': 'è¯·è¾“å…¥å£°éŸ³æè¿°',
                'status.modelLoading': 'æ¨¡å‹åŠ è½½ä¸­...',
                'status.saved': 'å·²ä¿å­˜',
                'status.saving': 'ä¿å­˜ä¸­...',
                'api.title': 'API æ–‡æ¡£',
                'api.presetTTS': 'é¢„è®¾è¯´è¯äºº TTS',
                'api.cloneTTS': 'è¯­éŸ³å…‹éš†',
                'api.designTTS': 'å£°éŸ³è®¾è®¡',
                'api.voiceLibrary': 'å£°éŸ³åº“ç®¡ç†',
                'confirm.delete': 'ç¡®å®šåˆ é™¤æ­¤å£°éŸ³ï¼Ÿ',
                'btn.regenerate': 'é‡æ–°ç”Ÿæˆ',
                'status.regenerating': 'é‡æ–°ç”Ÿæˆä¸­...',
                'status.inserting': 'æ­£åœ¨ç”Ÿæˆæ–°å¥å­...',
                'btn.editSentence': 'ç¼–è¾‘',
                'btn.backToText': 'è¿”å›ç¼–è¾‘è§†å›¾',
                'btn.sentenceView': 'è¿”å›å¥å­è§†å›¾',
                'btn.undo': 'æ’¤é”€',
                'btn.addSentence': 'æ·»åŠ å¥å­',
                'btn.insertHint': 'è¾“å…¥æ–°å¥å­æ–‡æœ¬',
                'confirm.deleteSentence': 'ç¡®å®šåˆ é™¤è¿™å¥ï¼Ÿ',
                'label.pace': 'å¥é—´åœé¡¿',
                'label.paceOff': 'æ— ',
                'label.paceSlow': 'æ…¢',
                'label.paceFast': 'å¿«',
                'label.instructEmpty': 'ç‚¹å‡»è®¾ç½®æƒ…æ„Ÿ',
                'label.instructLabel': 'æƒ…æ„Ÿ',
            },
            en: {
                'nav.preset': 'Preset Voices',
                'nav.clone': 'Voice Clone',
                'nav.design': 'Voice Design',
                'nav.api': 'API Docs',
                'main.title': 'Text to Speech',
                'main.placeholder': 'Enter text to convert...',
                'config.title': 'Settings',
                'config.speaker': 'Speaker',
                'config.language': 'Language',
                'config.instruct': 'Emotion',
                'config.instructPlaceholder': 'e.g., speak happily',
                'config.refAudio': 'Reference Audio',
                'config.refText': 'Reference Text',
                'config.refTextHint': '(optional)',
                'config.refTextPlaceholder': 'Transcript of reference audio',
                'config.preview': 'Preview',
                'config.voiceDesc': 'Voice Description',
                'config.voiceDescPlaceholder': 'Describe the voice you want',
                'config.saveName': 'Save to Library',
                'config.saveNamePlaceholder': 'Voice name',
                'clone.voiceLibrary': 'Voice Library',
                'btn.generate': 'Generate',
                'btn.record': 'Record',
                'btn.stopRecord': 'Stop',
                'btn.upload': 'Upload',
                'btn.save': 'Save',
                'btn.stop': 'Stop',
                'stats.chars': 'chars',
                'stats.sentences': 'sentences',
                'status.generating': 'Generating...',
                'status.success': 'Success',
                'status.failed': 'Failed',
                'status.stopped': 'Stopped',
                'status.enterText': 'Please enter text',
                'status.needAudio': 'Please record or upload audio',
                'status.needDesc': 'Please enter voice description',
                'status.modelLoading': 'Loading model...',
                'status.saved': 'Saved',
                'status.saving': 'Saving...',
                'api.title': 'API Documentation',
                'api.presetTTS': 'Preset Voice TTS',
                'api.cloneTTS': 'Voice Cloning',
                'api.designTTS': 'Voice Design',
                'api.voiceLibrary': 'Voice Library',
                'confirm.delete': 'Delete this voice?',
                'btn.regenerate': 'Regenerate',
                'status.regenerating': 'Regenerating...',
                'status.inserting': 'Generating new sentence...',
                'btn.editSentence': 'Edit',
                'btn.backToText': 'Back to editor',
                'btn.sentenceView': 'Back to sentences',
                'btn.undo': 'Undo',
                'btn.addSentence': 'Add sentence',
                'btn.insertHint': 'Enter new sentence text',
                'confirm.deleteSentence': 'Delete this sentence?',
                'label.pace': 'Pause',
                'label.paceOff': 'Off',
                'label.paceSlow': 'Slow',
                'label.paceFast': 'Fast',
                'label.instructEmpty': 'Click to set emotion',
                'label.instructLabel': 'Emotion',
            }
        };

        function t(key) {
            return i18n[currentLang][key] || key;
        }

        function updateI18n() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                el.textContent = t(el.dataset.i18n);
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                el.placeholder = t(el.dataset.i18nPlaceholder);
            });
            document.getElementById('lang-toggle').textContent = currentLang === 'zh' ? 'EN' : 'ä¸­';
            renderStats();
        }

        function toggleLanguage() {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            localStorage.setItem('lang', currentLang);
            updateI18n();
        }

        // ===== æ¨¡å¼åˆ‡æ¢ =====
        function switchMode(mode) {
            currentMode = mode;

            // æ›´æ–°å¯¼èˆªçŠ¶æ€
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.mode === mode);
            });

            // æ˜¾ç¤º/éšè—é…ç½®é¢æ¿
            document.getElementById('config-preset').classList.toggle('hidden', mode !== 'preset');
            document.getElementById('config-clone').classList.toggle('hidden', mode !== 'clone');
            document.getElementById('config-design').classList.toggle('hidden', mode !== 'design');

            // æ˜¾ç¤º/éšè—å£°éŸ³åº“
            document.getElementById('voice-library-section').classList.toggle('hidden', mode !== 'clone');

            // åˆ‡æ¢åˆ° clone æ¨¡å¼æ—¶åˆ·æ–°å£°éŸ³åº“åˆ—è¡¨ï¼ˆæ›´æ–°é€‰ä¸­çŠ¶æ€ï¼‰
            if (mode === 'clone') {
                renderVoiceList();
            } else {
                // ç¦»å¼€ clone æ¨¡å¼æ—¶æ¸…é™¤é€‰ä¸­
                selectedVoiceId = null;
            }

            // éšè—ä¿å­˜åŒºåŸŸï¼ˆæ’­æ”¾å™¨ä¿æŒä¸å˜ï¼‰
            document.getElementById('save-voice-section').classList.add('hidden');
        }

        // ===== é¡µé¢åˆ‡æ¢ =====
        function showPage(page) {
            document.getElementById('api-overlay').classList.toggle('hidden', page !== 'api');
        }

        // ===== å­—æ•°ç»Ÿè®¡ =====
        let langDetectTimer = null;
        function updateCharCount() {
            const text = document.getElementById('text-input').value;
            document.getElementById('char-count').innerHTML = `${text.length} <span data-i18n="stats.chars">${t('stats.chars')}</span>`;

            // æ–‡æœ¬ä¸ºç©ºæ—¶ç¦ç”¨ç”ŸæˆæŒ‰é’®
            const btn = document.getElementById('generate-btn');
            if (!isGenerating) {
                btn.disabled = text.trim().length === 0;
            }

            // è‡ªåŠ¨æ£€æµ‹è¯­è¨€ï¼ˆé˜²æŠ–500msï¼‰
            clearTimeout(langDetectTimer);
            langDetectTimer = setTimeout(() => detectAndSetLanguage(text), 500);
        }

        function detectAndSetLanguage(text) {
            if (!text.trim()) return;
            const counts = { zh: 0, ja: 0, ko: 0, en: 0 };
            for (const c of text) {
                const code = c.charCodeAt(0);
                if (code >= 0x4e00 && code <= 0x9fff) counts.zh++;
                else if ((code >= 0x3040 && code <= 0x30ff) || (code >= 0x31f0 && code <= 0x31ff)) counts.ja++;
                else if (code >= 0xac00 && code <= 0xd7af) counts.ko++;
                else if ((code >= 0x41 && code <= 0x5a) || (code >= 0x61 && code <= 0x7a)) counts.en++;
            }
            const total = counts.zh + counts.ja + counts.ko + counts.en;
            if (total < 5) return;
            let lang = null;
            if (counts.ja > 0 && counts.ja >= counts.zh * 0.1) lang = 'Japanese';
            else if (counts.ko > total * 0.3) lang = 'Korean';
            else if (counts.zh > total * 0.3) lang = 'Chinese';
            else if (counts.en > total * 0.5) lang = 'English';
            if (lang) {
                ['language-preset', 'language-clone', 'language-design'].forEach(id => {
                    document.getElementById(id).value = lang;
                });
            }
        }

        // ===== å£°éŸ³åº“ =====
        async function loadSavedVoices() {
            try {
                const response = await fetch('/voices');
                const data = await response.json();
                savedVoices = data.voices || [];
                renderVoiceList();
            } catch (error) {
                console.error('Failed to load voices:', error);
            }
        }

        // å£°éŸ³åº“é¢„è§ˆæ’­æ”¾å™¨
        let previewAudio = null;
        let previewingVoiceId = null;

        function renderVoiceList() {
            const container = document.getElementById('voice-list');
            if (savedVoices.length === 0) {
                container.innerHTML = `<div class="text-center text-charcoal/50 text-sm py-4">æš‚æ— ä¿å­˜çš„å£°éŸ³</div>`;
                return;
            }

            container.innerHTML = savedVoices.map(voice => `
                <div class="voice-card ${selectedVoiceId === voice.id ? 'selected' : ''}" onclick="selectVoice('${voice.id}')">
                    <div class="flex items-center justify-between">
                        <span class="text-sm font-medium truncate">${voice.name}</span>
                        <div class="flex gap-1">
                            <button id="preview-btn-${voice.id}" onclick="event.stopPropagation(); previewVoice('${voice.id}')" class="p-1 hover:bg-warm-gray rounded" title="é¢„è§ˆ">${previewingVoiceId === voice.id ? 'â¸' : 'â–¶'}</button>
                            <button onclick="event.stopPropagation(); deleteVoice('${voice.id}')" class="p-1 hover:bg-red-500/20 hover:text-red-600 rounded" title="åˆ é™¤">âœ•</button>
                        </div>
                    </div>
                    <div class="text-xs text-charcoal/50 mt-1">${voice.language}</div>
                </div>
            `).join('');
        }

        function selectVoice(voiceId) {
            selectedVoiceId = selectedVoiceId === voiceId ? null : voiceId;
            renderVoiceList();

            // é€‰ä¸­å£°éŸ³åº“æ—¶æ¸…é™¤å½•éŸ³/ä¸Šä¼ 
            if (selectedVoiceId) {
                clearAudio();
            }
        }

        function previewVoice(voiceId) {
            // å¦‚æœæ­£åœ¨æ’­æ”¾åŒä¸€ä¸ªå£°éŸ³ï¼Œåˆ™åœæ­¢
            if (previewingVoiceId === voiceId && previewAudio) {
                previewAudio.pause();
                previewAudio.currentTime = 0;
                previewAudio = null;
                previewingVoiceId = null;
                renderVoiceList();
                return;
            }

            // å¦‚æœæ­£åœ¨æ’­æ”¾å…¶ä»–å£°éŸ³ï¼Œå…ˆåœæ­¢
            if (previewAudio) {
                previewAudio.pause();
                previewAudio.currentTime = 0;
            }

            // æ’­æ”¾æ–°å£°éŸ³
            previewAudio = new Audio(`/voices/${voiceId}/preview`);
            previewingVoiceId = voiceId;
            renderVoiceList();

            previewAudio.play();

            // æ’­æ”¾ç»“æŸåé‡ç½®çŠ¶æ€
            previewAudio.onended = () => {
                previewingVoiceId = null;
                previewAudio = null;
                renderVoiceList();
            };
        }

        async function deleteVoice(voiceId) {
            if (!confirm(t('confirm.delete'))) return;
            try {
                await fetch(`/voices/${voiceId}`, { method: 'DELETE' });
                if (selectedVoiceId === voiceId) selectedVoiceId = null;
                await loadSavedVoices();
            } catch (error) {
                alert('åˆ é™¤å¤±è´¥: ' + error.message);
            }
        }

        async function saveVoice() {
            const name = document.getElementById('voice-name').value.trim();
            if (!name) return;

            const language = document.getElementById('language-clone').value;
            const refText = document.getElementById('ref-text').value.trim();

            let audioFile = recordedBlob ? new File([recordedBlob], 'recording.webm', { type: 'audio/webm' }) : selectedFile;
            if (!audioFile) return;

            const formData = new FormData();
            formData.append('name', name);
            formData.append('language', language);
            formData.append('ref_text', refText);
            formData.append('audio', audioFile);

            const statusEl = document.getElementById('status-message');
            statusEl.textContent = t('status.saving');

            try {
                const response = await fetch('/voices/save', { method: 'POST', body: formData });
                if (!response.ok) throw new Error('Save failed');
                statusEl.textContent = t('status.saved');
                document.getElementById('voice-name').value = '';
                await loadSavedVoices();
            } catch (error) {
                statusEl.textContent = t('status.failed') + ': ' + error.message;
            }
        }

        // ===== å½•éŸ³ =====
        async function toggleRecording() {
            const btn = document.getElementById('record-btn');
            const icon = document.getElementById('record-icon');
            const text = document.getElementById('record-text');
            const timer = document.getElementById('record-timer');

            if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                    audioChunks = [];

                    mediaRecorder.ondataavailable = e => {
                        if (e.data.size > 0) audioChunks.push(e.data);
                    };

                    mediaRecorder.onstop = () => {
                        stream.getTracks().forEach(track => track.stop());
                        recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        selectedFile = null;

                        // å–æ¶ˆå£°éŸ³åº“é€‰ä¸­
                        if (selectedVoiceId) {
                            selectedVoiceId = null;
                            renderVoiceList();
                        }

                        showAudioPreview(URL.createObjectURL(recordedBlob));

                        icon.textContent = 'ğŸ™ï¸';
                        text.textContent = t('btn.record');
                        timer.classList.add('hidden');
                        btn.classList.remove('bg-red-500/20', 'border-red-500');
                        clearInterval(timerInterval);
                    };

                    mediaRecorder.start();
                    recordingStartTime = Date.now();

                    icon.innerHTML = '<div class="recording-indicator"></div>';
                    text.textContent = t('btn.stopRecord');
                    timer.classList.remove('hidden');
                    timer.textContent = '00:00';
                    btn.classList.add('bg-red-500/20', 'border-red-500');

                    timerInterval = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                        timer.textContent = `${String(Math.floor(elapsed / 60)).padStart(2, '0')}:${String(elapsed % 60).padStart(2, '0')}`;
                    }, 100);

                } catch (err) {
                    alert('æ— æ³•è®¿é—®éº¦å…‹é£: ' + err.message);
                }
            } else if (mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        function handleFileSelect(input) {
            const file = input.files[0];
            if (file) {
                selectedFile = file;
                recordedBlob = null;

                // å–æ¶ˆå£°éŸ³åº“é€‰ä¸­
                if (selectedVoiceId) {
                    selectedVoiceId = null;
                    renderVoiceList();
                }

                showAudioPreview(URL.createObjectURL(file));
            }
        }

        function showAudioPreview(url) {
            document.getElementById('audio-preview-section').classList.remove('hidden');
            document.getElementById('audio-preview').src = url;
        }

        function clearAudio() {
            recordedBlob = null;
            selectedFile = null;
            document.getElementById('audio-preview-section').classList.add('hidden');
            document.getElementById('audio-preview').src = '';
            document.getElementById('audio-file').value = '';
        }

        // ===== ç”Ÿæˆè¯­éŸ³ =====

        // åˆ†å¥è¿›åº¦ç”Ÿæˆ
        let currentEventSource = null;
        let isGenerating = false;
        let currentSubtitles = null;

        function stopGeneration() {
            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }
            isGenerating = false;
            currentSubtitles = null;
            sentenceAudios = [];
            sentenceTexts = [];
            sentenceInstructs = [];
            decodedPcmCache = [];
            selectedSentenceIndex = -1;
            undoStack = [];
            sentencePreviewIndex = -1;
            if (_sentencePreviewEndHandler) {
                audioElement.removeEventListener('timeupdate', _sentencePreviewEndHandler);
                _sentencePreviewEndHandler = null;
            }
            // éšè—è¿›åº¦è§†å›¾
            const textInput = document.getElementById('text-input');
            const progressView = document.getElementById('progress-view');
            textInput.classList.remove('hidden');
            progressView.classList.add('hidden');

            const btn = document.getElementById('generate-btn');
            const statusEl = document.getElementById('status-message');
            btn.disabled = false;
            btn.onclick = generate;
            btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
            statusEl.innerHTML = `<span class="text-yellow-600">${t('status.stopped')}</span>`;
            updateCharCount();
        }

        // å‰ç«¯åˆ†å¥ï¼ˆä¸åç«¯ä¿æŒä¸€è‡´ï¼‰
        function splitTextToSentences(text, minLength = 10) {
            const pattern = /([ã€‚ï¼ï¼Ÿï¼›.!?;]+|\n)/;
            const parts = text.split(pattern);

            const rawSentences = [];
            let current = '';
            for (const part of parts) {
                current += part;
                if (pattern.test(part)) {
                    if (current.trim()) {
                        rawSentences.push(current.trim());
                    }
                    current = '';
                }
            }
            if (current.trim()) {
                rawSentences.push(current.trim());
            }

            if (rawSentences.length === 0) {
                return text.trim() ? [text] : [];
            }

            // åˆå¹¶è¿‡çŸ­çš„å¥å­
            const merged = [];
            let buffer = '';
            for (const sentence of rawSentences) {
                buffer += sentence;
                if (buffer.length >= minLength) {
                    merged.push(buffer);
                    buffer = '';
                }
            }
            if (buffer) {
                if (merged.length > 0) {
                    merged[merged.length - 1] += buffer;
                } else {
                    merged.push(buffer);
                }
            }
            return merged;
        }

        // æ˜¾ç¤ºè¿›åº¦è§†å›¾
        function showProgressView(sentences) {
            const textInput = document.getElementById('text-input');
            const progressView = document.getElementById('progress-view');

            // æ„å»ºå¸¦æ ·å¼çš„å¥å­åˆ—è¡¨
            let html = '';
            sentences.forEach((sentence, index) => {
                html += `<span id="sentence-${index}" class="sentence-pending">${escapeHtml(sentence)}</span>`;
            });

            progressView.innerHTML = html;
            textInput.classList.add('hidden');
            progressView.classList.remove('hidden');
        }

        // æ›´æ–°å¥å­è¿›åº¦æ ·å¼
        function updateSentenceProgress(current) {
            // current æ˜¯å·²å®Œæˆçš„æ•°é‡ï¼ˆ1-basedï¼‰
            for (let i = 0; i < current; i++) {
                const el = document.getElementById(`sentence-${i}`);
                if (el) {
                    el.className = 'sentence-done';
                }
            }
            // æ ‡è®°æ­£åœ¨ç”Ÿæˆçš„å¥å­
            const currentEl = document.getElementById(`sentence-${current}`);
            if (currentEl) {
                currentEl.className = 'sentence-current';
            }
        }

        // éšè—è¿›åº¦è§†å›¾
        function hideProgressView() {
            const textInput = document.getElementById('text-input');
            const progressView = document.getElementById('progress-view');
            textInput.classList.remove('hidden');
            progressView.style.display = '';
            progressView.style.flexDirection = '';
            progressView.style.overflow = '';
            progressView.classList.add('hidden');
            // å¦‚æœæœ‰å¥å­æ•°æ®ï¼Œæ˜¾ç¤º"è¿”å›å¥å­è§†å›¾"æŒ‰é’®
            const hint = document.getElementById('sentence-view-hint');
            if (hint) {
                hint.classList.toggle('hidden', sentenceAudios.length <= 1);
            }
            updateCharCount();
            // æ¢å¤ç”ŸæˆæŒ‰é’®ï¼Œéšè—å¥å­å·¥å…·æ 
            document.getElementById('generate-btn').style.display = '';
            const toolbar = document.getElementById('sentence-toolbar');
            toolbar.style.display = 'none';
            toolbar.classList.add('hidden');
        }

        // æ˜¾ç¤ºå¥å­ç¼–è¾‘è§†å›¾
        let selectedSentenceIndex = -1;

        function showSentenceEditorView() {
            const textInput = document.getElementById('text-input');
            const progressView = document.getElementById('progress-view');

            // æ‰¾å‡ºæœ€è¿‘ä¸€æ¬¡æ’¤é”€å¯¹åº”çš„å¥å­ç´¢å¼•
            const lastUndoIndex = undoStack.length > 0 ? undoStack[undoStack.length - 1].index : -1;

            let html = '<div style="flex:1;min-height:0;overflow-y:auto" class="scrollbar-thin"><ul class="sentence-editor-list">';
            // ç¬¬ä¸€å¥å‰é¢çš„æ’å…¥æŒ‰é’®
            html += `<li class="sentence-insert-row"><button class="sentence-insert-btn" onclick="event.stopPropagation(); showInsertForm(0)" title="${t('btn.addSentence')}">ï¼‹</button></li>`;
            sentenceTexts.forEach((text, index) => {
                const isSelected = index === selectedSentenceIndex;
                const isPreviewPlaying = sentencePreviewIndex === index;
                const hasUndo = index === lastUndoIndex;
                const instruct = sentenceInstructs[index] || '';
                const isPreset = lastGenerateParams && lastGenerateParams.mode === 'preset';
                const instructTag = isPreset ? `<div class="sentence-instruct-tag" id="sent-instruct-${index}" onclick="event.stopPropagation(); editSentenceInstruct(${index})"><span class="sentence-instruct-label">${t('label.instructLabel')}:</span> <span class="sentence-instruct-value">${instruct ? escapeHtml(instruct) : t('label.instructEmpty')}</span> <span class="sentence-instruct-edit">âœ</span></div>` : '';
                html += `<li class="sentence-editor-item ${isSelected ? 'selected' : ''}"
                    id="sent-item-${index}"
                    onclick="selectSentenceItem(${index}, event)"
                    ondblclick="editSentenceItem(${index})">
                    <span class="sentence-editor-index">${index + 1}</span>
                    <div style="flex:1;min-width:0">
                        <span class="sentence-editor-text" id="sent-text-${index}">${escapeHtml(text)}</span>
                        ${instructTag}
                    </div>
                    <span class="sentence-editor-actions">
                        ${hasUndo ? '<button class="sentence-regen-btn" onclick="event.stopPropagation(); undoRegenerate()" title="' + t('btn.undo') + '" style="border-color:#f6ad55;color:#dd6b20">â†©</button>' : ''}
                        <button class="sentence-play-btn ${isPreviewPlaying ? 'playing-now' : ''}" onclick="event.stopPropagation(); previewSentenceAudio(${index})" title="è¯•å¬">${isPreviewPlaying ? 'â¸' : 'â–¶'}</button>
                        <button class="sentence-regen-btn" onclick="event.stopPropagation(); regenerateSentence(${index})">${t('btn.regenerate')}</button>
                        <button class="sentence-del-btn" onclick="event.stopPropagation(); deleteSentence(${index})" title="åˆ é™¤">âœ•</button>
                    </span>
                </li>`;
                // æ’å…¥æŒ‰é’®ï¼ˆæ¯å¥ä¹‹åï¼‰
                html += `<li class="sentence-insert-row"><button class="sentence-insert-btn" onclick="event.stopPropagation(); showInsertForm(${index + 1})" title="${t('btn.addSentence')}">ï¼‹</button></li>`;
            });
            html += '</ul></div>';

            progressView.innerHTML = html;
            textInput.classList.add('hidden');
            progressView.style.display = 'flex';
            progressView.style.flexDirection = 'column';
            progressView.style.overflow = 'hidden';
            progressView.classList.remove('hidden');
            // éšè—"è¿”å›å¥å­è§†å›¾"æç¤º
            const hint = document.getElementById('sentence-view-hint');
            if (hint) hint.classList.add('hidden');
            // éšè—ç”ŸæˆæŒ‰é’®ï¼Œæ˜¾ç¤ºå¥å­å·¥å…·æ 
            document.getElementById('generate-btn').style.display = 'none';
            const toolbar = document.getElementById('sentence-toolbar');
            toolbar.classList.remove('hidden');
            toolbar.style.display = 'flex';
            // åŒæ­¥åœé¡¿æ§ä»¶å€¼
            document.getElementById('st-pace-label').textContent = t('label.pace');
            document.getElementById('st-pace-value').textContent = pausePaceMultiplier === 0 ? t('label.paceOff') : pausePaceMultiplier.toFixed(1) + 'x';
            document.getElementById('st-pace-range').value = pausePaceMultiplier;
        }

        function exitSentenceEditorView() {
            finishEditing();
            selectedSentenceIndex = -1;
            // åŒæ­¥å¥å­æ–‡æœ¬å› textarea
            if (sentenceTexts.length > 0) {
                document.getElementById('text-input').value = sentenceTexts.join('');
            }
            hideProgressView();
        }

        function selectSentenceItem(index, event) {
            // å¦‚æœç‚¹å‡»å‘ç”Ÿåœ¨æ­£åœ¨ç¼–è¾‘çš„ contenteditable å†…ï¼Œä¸å¤„ç†ï¼ˆè®©å…‰æ ‡è‡ªç”±ç§»åŠ¨ï¼‰
            if (event && event.target.closest('[contenteditable="true"]')) return;

            // å¦‚æœæœ‰æ­£åœ¨ç¼–è¾‘çš„å¥å­ï¼Œå…ˆä¿å­˜
            finishEditing();

            selectedSentenceIndex = selectedSentenceIndex === index ? -1 : index;
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.sentence-editor-item').forEach((el, i) => {
                el.classList.toggle('selected', i === selectedSentenceIndex);
            });
        }

        function editSentenceItem(index) {
            // å¦‚æœå·²ç»åœ¨ç¼–è¾‘è¿™å¥äº†ï¼Œä¸é‡å¤å¤„ç†
            const textEl = document.getElementById(`sent-text-${index}`);
            if (textEl && textEl.contentEditable === 'true') return;

            finishEditing();
            selectedSentenceIndex = index;
            document.querySelectorAll('.sentence-editor-item').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
            });
            if (textEl) {
                textEl.contentEditable = 'true';
                textEl.focus();
                // å…‰æ ‡æ”¾åˆ°æœ«å°¾
                const range = document.createRange();
                range.selectNodeContents(textEl);
                range.collapse(false);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
                // Enter é”®å®Œæˆç¼–è¾‘
                textEl.onkeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        finishEditing();
                    }
                };
            }
        }

        function finishEditing() {
            let changed = false;
            document.querySelectorAll('.sentence-editor-text[contenteditable="true"]').forEach(el => {
                el.contentEditable = 'false';
                el.onkeydown = null;
                // è·å–ç´¢å¼•å¹¶æ›´æ–° sentenceTexts
                const idMatch = el.id.match(/sent-text-(\d+)/);
                if (idMatch) {
                    const idx = parseInt(idMatch[1]);
                    const newText = el.textContent.trim();
                    if (newText && newText !== sentenceTexts[idx]) {
                        sentenceTexts[idx] = newText;
                        changed = true;
                    }
                }
            });
            if (changed) {
                refreshStatsFromSentences();
                saveSession(); // æ–‡æœ¬ç¼–è¾‘åæŒä¹…åŒ–
            }
        }

        // ===== é€å¥æƒ…æ„Ÿç¼–è¾‘ =====
        function editSentenceInstruct(index) {
            const tag = document.getElementById(`sent-instruct-${index}`);
            if (!tag) return;
            if (tag.querySelector('input')) return; // å·²åœ¨ç¼–è¾‘ä¸­
            const currentVal = sentenceInstructs[index] || '';
            tag.innerHTML = `<input type="text" class="sentence-instruct-input"
                value="${escapeHtml(currentVal)}"
                placeholder="${t('label.instructEmpty')}"
                onblur="finishInstructEdit(${index}, this)"
                onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}if(event.key==='Escape'){this.blur();}">`;
            const input = tag.querySelector('input');
            input.focus();
            input.select();
        }

        function finishInstructEdit(index, inputEl) {
            const newVal = inputEl.value.trim();
            sentenceInstructs[index] = newVal;
            saveSession();
            showSentenceEditorView();
        }

        // ===== å•å¥è¯•å¬ =====
        let _sentencePreviewEndHandler = null;

        function previewSentenceAudio(index) {
            // æ¸…é™¤ä¹‹å‰çš„å¥å°¾ç›‘å¬
            if (_sentencePreviewEndHandler) {
                audioElement.removeEventListener('timeupdate', _sentencePreviewEndHandler);
                _sentencePreviewEndHandler = null;
            }
            // å¦‚æœæ­£åœ¨æ’­æ”¾åŒä¸€å¥ï¼Œåœæ­¢
            if (sentencePreviewIndex === index && !audioElement.paused) {
                audioElement.pause();
                sentencePreviewIndex = -1;
                showSentenceEditorView();
                return;
            }

            const sub = currentSubtitles && currentSubtitles[index];
            if (!sub) return;

            // æš‚åœå½“å‰æ’­æ”¾
            if (!audioElement.paused) audioElement.pause();

            sentencePreviewIndex = index;
            showSentenceEditorView();

            // seek åˆ°å¥å­èµ·ç‚¹å¹¶æ’­æ”¾
            audioElement.currentTime = sub.start;
            audioElement.play();

            // ç›‘å¬ timeupdateï¼Œåˆ°å¥å°¾è‡ªåŠ¨åœæ­¢
            const endTime = sub.end;
            _sentencePreviewEndHandler = () => {
                if (audioElement.currentTime >= endTime) {
                    audioElement.pause();
                    audioElement.removeEventListener('timeupdate', _sentencePreviewEndHandler);
                    _sentencePreviewEndHandler = null;
                    sentencePreviewIndex = -1;
                    showSentenceEditorView();
                }
            };
            audioElement.addEventListener('timeupdate', _sentencePreviewEndHandler);
        }

        // ===== æ’¤é”€é‡æ–°ç”Ÿæˆ =====
        function undoRegenerate() {
            if (undoStack.length === 0) return;
            const last = undoStack.pop();
            sentenceAudios[last.index] = last.audio;
            sentenceTexts[last.index] = last.text;
            if (last.instruct !== undefined) sentenceInstructs[last.index] = last.instruct;
            // é‡æ–°åˆå¹¶
            rebuildAudioAndSubtitles();
            saveSession(); // æŒä¹…åŒ–
            selectedSentenceIndex = last.index;
            showSentenceEditorView();
            const statusEl = document.getElementById('status-message');
            statusEl.innerHTML = `<span class="text-yellow-600">${t('btn.undo')}</span>`;
        }

        // ===== åˆ é™¤å¥å­ =====
        function deleteSentence(index) {
            if (sentenceTexts.length <= 1) return; // è‡³å°‘ä¿ç•™ä¸€å¥
            if (!confirm(t('confirm.deleteSentence'))) return;
            finishEditing();
            sentenceAudios.splice(index, 1);
            sentenceTexts.splice(index, 1);
            sentenceInstructs.splice(index, 1);
            decodedPcmCache = [];
            rebuildAudioAndSubtitles();
            saveSession(); // æŒä¹…åŒ–
            if (selectedSentenceIndex >= sentenceTexts.length) selectedSentenceIndex = sentenceTexts.length - 1;
            if (selectedSentenceIndex === index) selectedSentenceIndex = -1;
            refreshStatsFromSentences();
            showSentenceEditorView();
        }

        // ===== æ’å…¥å¥å­ =====
        function showInsertForm(afterIndex) {
            if (!lastGenerateParams) return;
            finishEditing();
            // å–æ¶ˆå·²æœ‰çš„æ’å…¥è¡¨å•
            const existing = document.querySelector('.insert-form-row');
            if (existing) existing.remove();

            const editorList = document.querySelector('.sentence-editor-list');
            if (!editorList) return;

            const isPreset = lastGenerateParams.mode === 'preset';
            const defaultInstruct = lastGenerateParams.instruct || '';
            const instructRow = isPreset ? `<div style="display:flex;align-items:center;gap:6px">
                <span style="font-size:11px;color:#A0AEC0;white-space:nowrap">${t('label.instructLabel')}:</span>
                <input type="text" id="insert-instruct-input" value="${escapeHtml(defaultInstruct)}" placeholder="${t('label.instructEmpty')}" style="flex:1">
            </div>` : '';

            const formHtml = `<li class="insert-form-row"><div class="sentence-insert-form">
                <input type="text" id="insert-text-input" placeholder="${t('btn.insertHint')}" autofocus>
                ${instructRow}
                <div class="sentence-insert-form-actions">
                    <button onclick="cancelInsertForm()">${t('btn.stop')}</button>
                    <button class="confirm-btn" onclick="confirmInsert(${afterIndex})">${t('btn.addSentence')}</button>
                </div>
            </div></li>`;

            // æ‰¾åˆ° afterIndex å¯¹åº”çš„æ’å…¥æŒ‰é’®è¡Œ
            const items = editorList.children;
            const insertBtnIndex = afterIndex * 2;
            if (insertBtnIndex >= 0 && insertBtnIndex < items.length) {
                items[insertBtnIndex].insertAdjacentHTML('afterend', formHtml);
            } else {
                editorList.insertAdjacentHTML('afterbegin', formHtml);
            }

            const textInput = document.getElementById('insert-text-input');
            textInput.focus();
            // Enter ç¡®è®¤ï¼ŒEscape å–æ¶ˆ
            const handleKey = (e) => {
                if (e.key === 'Enter') { e.preventDefault(); confirmInsert(afterIndex); }
                if (e.key === 'Escape') { e.preventDefault(); cancelInsertForm(); }
            };
            textInput.addEventListener('keydown', handleKey);
            const instructInput = document.getElementById('insert-instruct-input');
            if (instructInput) instructInput.addEventListener('keydown', handleKey);
        }

        function cancelInsertForm() {
            const row = document.querySelector('.insert-form-row');
            if (row) row.remove();
        }

        async function confirmInsert(afterIndex) {
            const textInput = document.getElementById('insert-text-input');
            const instructInput = document.getElementById('insert-instruct-input');
            const newText = textInput ? textInput.value.trim() : '';
            const newInstruct = instructInput ? instructInput.value.trim() : (lastGenerateParams.instruct || '');
            if (!newText) { textInput && textInput.focus(); return; }

            // ç§»é™¤è¡¨å•ï¼Œæ˜¾ç¤ºå ä½è¡Œ
            cancelInsertForm();

            const statusEl = document.getElementById('status-message');
            const btn = document.getElementById('generate-btn');
            const editorList = document.querySelector('.sentence-editor-list');

            if (editorList) {
                editorList.classList.add('inserting');
                const placeholderHtml = `<li class="inserting-row"><div class="sentence-inserting-placeholder">
                    <span class="spinner" style="width:14px;height:14px;border-width:2px"></span>
                    <span>${escapeHtml(newText.length > 30 ? newText.slice(0, 30) + '...' : newText)}</span>
                </div></li>`;
                const items = editorList.children;
                const insertBtnIndex = afterIndex * 2;
                if (insertBtnIndex >= 0 && insertBtnIndex < items.length) {
                    items[insertBtnIndex].insertAdjacentHTML('afterend', placeholderHtml);
                } else {
                    editorList.insertAdjacentHTML('afterbegin', placeholderHtml);
                }
            }

            const originalBtnHtml = btn.innerHTML;
            const originalBtnOnclick = btn.onclick;
            btn.disabled = true;

            try {
                const formData = new FormData();
                formData.append('sentence_text', newText);
                formData.append('mode', lastGenerateParams.mode);
                formData.append('language', lastGenerateParams.language);
                if (lastGenerateParams.speaker) formData.append('speaker', lastGenerateParams.speaker);
                // ä½¿ç”¨æ–°å¥å­æŒ‡å®šçš„ instruct
                const instruct = (lastGenerateParams.mode === 'preset' && newInstruct)
                    ? newInstruct : lastGenerateParams.instruct;
                if (instruct) formData.append('instruct', instruct);
                if (lastGenerateParams.voice_id) formData.append('voice_id', lastGenerateParams.voice_id);
                if (lastGenerateParams.clone_prompt_id) formData.append('clone_prompt_id', lastGenerateParams.clone_prompt_id);

                const response = await fetch('/regenerate', { method: 'POST', body: formData });
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Generate failed');
                }
                const data = await response.json();

                sentenceAudios.splice(afterIndex, 0, data.audio);
                sentenceTexts.splice(afterIndex, 0, newText);
                sentenceInstructs.splice(afterIndex, 0, newInstruct);
                decodedPcmCache = [];
                rebuildAudioAndSubtitles();
                saveSession();
                selectedSentenceIndex = afterIndex;
                refreshStatsFromSentences();
                showSentenceEditorView();

                const subtitle = currentSubtitles[afterIndex];
                if (subtitle) {
                    audioElement.addEventListener('loadedmetadata', function jumpToNew() {
                        audioElement.currentTime = subtitle.start;
                        audioElement.play();
                        audioElement.removeEventListener('loadedmetadata', jumpToNew);
                    });
                }
            } catch (error) {
                statusEl.innerHTML = `<span class="text-red-600">${t('status.failed')}: ${error.message}</span>`;
                if (editorList) {
                    const placeholder = editorList.querySelector('.inserting-row');
                    if (placeholder) placeholder.remove();
                    editorList.classList.remove('inserting');
                }
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalBtnHtml;
                btn.onclick = originalBtnOnclick;
            }
        }

        // ===== é‡å»ºåˆå¹¶éŸ³é¢‘å’Œå­—å¹• =====
        function rebuildAudioAndSubtitles() {
            const merged = mergeAllSentenceAudios();
            currentSubtitles = merged.subtitles;
            audioElement.src = URL.createObjectURL(merged.blob);
            loadWaveform();
        }

        // è§£ç  base64 WAV ä¸º PCM samplesï¼ˆInt16Arrayï¼‰å’Œé‡‡æ ·ç‡
        function decodeBase64Wav(b64) {
            const binaryString = atob(b64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
            const wavData = parseWav(bytes.buffer);
            return wavData; // { samples: Int16Array, sampleRate, numChannels }
        }

        // æ ¹æ®å¥å°¾æ ‡ç‚¹åˆ¤æ–­åœé¡¿æ—¶é•¿ï¼ˆç§’ï¼‰ï¼Œå†ä¹˜ä»¥ pace å€ç‡
        function getPauseDuration(text) {
            if (pausePaceMultiplier === 0) return 0;
            if (!text || !text.trim()) return 0;
            // å…ˆæ£€æŸ¥åŸå§‹æ–‡æœ¬æ˜¯å¦ä»¥æ¢è¡Œç»“å°¾ï¼ˆæ®µè½åˆ†éš”ï¼‰
            if (/[\n\r]\s*$/.test(text)) return 0.6 * pausePaceMultiplier;
            const trimmed = text.trimEnd();
            const lastChar = trimmed[trimmed.length - 1];
            let base = 0;
            if (/[ã€‚ï¼Ÿï¼?!]/.test(lastChar)) base = 0.3;
            else if (/[ï¼›;ï¼Œ,ã€ï¼š:]/.test(lastChar)) base = 0.2;
            else base = 0.15; // æ— æ ‡ç‚¹é»˜è®¤çŸ­åœé¡¿
            return base * pausePaceMultiplier;
        }

        // å°†æ‰€æœ‰ sentenceAudios åˆå¹¶ä¸ºä¸€ä¸ª WAV Blobï¼ŒåŒæ—¶é‡ç®—å­—å¹•
        function mergeAllSentenceAudios() {
            const allChunks = []; // { samples: Int16Array } åŒ…å«éŸ³é¢‘å’Œé™éŸ³ç‰‡æ®µ
            let totalLength = 0;
            const subtitles = [];
            let currentTime = 0;
            let sampleRate = 24000;

            for (let i = 0; i < sentenceAudios.length; i++) {
                // ä¼˜å…ˆç”¨ç¼“å­˜ï¼Œé¿å…é‡å¤ base64 è§£ç 
                if (!decodedPcmCache[i] || decodedPcmCache[i]._src !== sentenceAudios[i]) {
                    const decoded = decodeBase64Wav(sentenceAudios[i]);
                    decoded._src = sentenceAudios[i]; // æ ‡è®°æ¥æºï¼ŒéŸ³é¢‘å˜åŒ–æ—¶å¤±æ•ˆ
                    decodedPcmCache[i] = decoded;
                }
                const wav = decodedPcmCache[i];
                sampleRate = wav.sampleRate;

                // æ·»åŠ éŸ³é¢‘
                allChunks.push(wav.samples);
                totalLength += wav.samples.length;

                const duration = wav.samples.length / sampleRate;
                subtitles.push({
                    text: sentenceTexts[i],
                    start: Math.round(currentTime * 1000) / 1000,
                    end: Math.round((currentTime + duration) * 1000) / 1000,
                });
                currentTime += duration;

                // å¥é—´æ’å…¥é™éŸ³ï¼ˆæœ€åä¸€å¥é™¤å¤–ï¼‰
                if (i < sentenceAudios.length - 1) {
                    const pauseSec = getPauseDuration(sentenceTexts[i]);
                    if (pauseSec > 0) {
                        const silenceSamples = Math.round(pauseSec * sampleRate);
                        allChunks.push(new Int16Array(silenceSamples)); // å…¨é›¶ = é™éŸ³
                        totalLength += silenceSamples;
                        currentTime += pauseSec;
                    }
                }
            }

            // åˆå¹¶ PCM
            const merged = new Int16Array(totalLength);
            let offset = 0;
            for (const samples of allChunks) {
                merged.set(samples, offset);
                offset += samples.length;
            }

            // ç¼–ç ä¸º WAV
            const wavBlob = encodeWav(merged, sampleRate);
            return { blob: wavBlob, subtitles };
        }

        // å°† Int16Array PCM ç¼–ç ä¸º WAV Blob
        function encodeWav(samples, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = samples.length * 2;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            // PCM data
            const output = new Int16Array(buffer, 44);
            output.set(samples);

            return new Blob([buffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, str) {
            for (let i = 0; i < str.length; i++) {
                view.setUint8(offset + i, str.charCodeAt(i));
            }
        }

        async function regenerateSentence(index) {
            if (!lastGenerateParams) return;
            finishEditing();

            // ä¿å­˜åˆ°æ’¤é”€æ ˆ
            undoStack.push({ index, audio: sentenceAudios[index], text: sentenceTexts[index], instruct: sentenceInstructs[index] });

            const text = sentenceTexts[index];
            const item = document.getElementById(`sent-item-${index}`);
            const actionsEl = item ? item.querySelector('.sentence-editor-actions') : null;
            let originalActionsHtml = '';
            if (actionsEl) {
                originalActionsHtml = actionsEl.innerHTML;
                actionsEl.innerHTML = `<span class="spinner" style="width:16px;height:16px;border-width:2px;color:#E07A5F"></span><span style="font-size:12px;color:#E07A5F">${t('status.regenerating')}</span>`;
                actionsEl.style.opacity = '1';
            }
            if (item) item.classList.add('regenerating');

            const statusEl = document.getElementById('status-message');
            statusEl.textContent = t('status.regenerating');

            try {
                const formData = new FormData();
                formData.append('sentence_text', text);
                formData.append('mode', lastGenerateParams.mode);
                formData.append('language', lastGenerateParams.language);
                if (lastGenerateParams.speaker) formData.append('speaker', lastGenerateParams.speaker);
                // é€å¥æƒ…æ„ŸæŒ‡ä»¤ï¼ˆpreset æ¨¡å¼ä¼˜å…ˆä½¿ç”¨é€å¥å€¼ï¼‰
                const instruct = (lastGenerateParams.mode === 'preset' && sentenceInstructs[index])
                    ? sentenceInstructs[index] : lastGenerateParams.instruct;
                if (instruct) formData.append('instruct', instruct);
                if (lastGenerateParams.voice_id) formData.append('voice_id', lastGenerateParams.voice_id);
                if (lastGenerateParams.clone_prompt_id) formData.append('clone_prompt_id', lastGenerateParams.clone_prompt_id);

                const response = await fetch('/regenerate', { method: 'POST', body: formData });
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Regenerate failed');
                }

                const data = await response.json();

                // æ›¿æ¢è¯¥å¥çš„éŸ³é¢‘å’Œæ–‡æœ¬
                sentenceAudios[index] = data.audio;
                sentenceTexts[index] = text;

                // å‰ç«¯åˆå¹¶æ‰€æœ‰å¥å­éŸ³é¢‘ + é‡ç®—å­—å¹•
                rebuildAudioAndSubtitles();

                // è·³è½¬åˆ°è¯¥å¥å¼€å¤´æ’­æ”¾
                const subtitle = currentSubtitles[index];
                if (subtitle) {
                    audioElement.addEventListener('loadedmetadata', function jumpToSentence() {
                        audioElement.currentTime = subtitle.start;
                        audioElement.play();
                        audioElement.removeEventListener('loadedmetadata', jumpToSentence);
                    });
                }

                statusEl.innerHTML = `<span class="text-green-600">${t('status.success')}</span>`;
                saveSession(); // æŒä¹…åŒ–

                // é‡æ–°æ¸²æŸ“å¥å­åˆ—è¡¨
                selectedSentenceIndex = index;
                showSentenceEditorView();

            } catch (error) {
                // å›æ»šæ’¤é”€æ ˆï¼ˆç”Ÿæˆå¤±è´¥ï¼Œæ— éœ€æ’¤é”€ï¼‰
                undoStack.pop();
                statusEl.innerHTML = `<span class="text-red-600">${t('status.failed')}: ${error.message}</span>`;
                // æ¢å¤æŒ‰é’®
                if (actionsEl) {
                    actionsEl.innerHTML = originalActionsHtml;
                    actionsEl.style.opacity = '';
                }
                if (item) item.classList.remove('regenerating');
            }
        }

        // HTML è½¬ä¹‰
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function generateWithProgress(url, btn, statusEl) {
            isGenerating = true;

            // è·å–æ–‡æœ¬å¹¶åˆ†å¥æ˜¾ç¤º
            const text = document.getElementById('text-input').value.trim();
            const sentences = splitTextToSentences(text);
            showProgressView(sentences);

            return new Promise((resolve, reject) => {
                const eventSource = new EventSource(url);
                currentEventSource = eventSource;
                let totalSentences = 0;

                eventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);

                        if (data.started) {
                            totalSentences = data.total;
                            statusEl.textContent = `${t('status.generating')} 0/${totalSentences} ${t('stats.sentences')} (0%)`;
                            // æ˜¾ç¤ºåœæ­¢æŒ‰é’®
                            btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="6" width="12" height="12"></rect></svg><span>${t('btn.stop')}</span>`;
                            btn.disabled = false;
                            btn.onclick = stopGeneration;
                            // æ ‡è®°ç¬¬ä¸€å¥æ­£åœ¨ç”Ÿæˆ
                            updateSentenceProgress(0);
                        }

                        if (data.progress) {
                            const { current, total, percent } = data.progress;
                            btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="6" width="12" height="12"></rect></svg><span>${current}/${total} ${t('stats.sentences')} (${percent}%)</span>`;
                            statusEl.textContent = `${t('status.generating')} ${current}/${total} ${t('stats.sentences')} (${percent}%)`;
                            // æ›´æ–°å¥å­æ ·å¼
                            updateSentenceProgress(current);
                        }

                        if (data.done) {
                            eventSource.close();
                            currentEventSource = null;
                            isGenerating = false;
                            currentSubtitles = data.subtitles || null;

                            // ä¿å­˜æ¯å¥éŸ³é¢‘å’Œæ–‡æœ¬
                            if (data.sentence_audios) {
                                sentenceAudios = data.sentence_audios;
                                sentenceTexts = (data.subtitles || []).map(s => s.text);
                                sentenceInstructs = sentenceTexts.map(() => lastGenerateParams?.instruct || '');
                            }
                            if (data.clone_prompt_id) {
                                clonePromptId = data.clone_prompt_id;
                                if (lastGenerateParams) lastGenerateParams.clone_prompt_id = data.clone_prompt_id;
                            }
                            saveSession(); // æŒä¹…åŒ–

                            // æ˜¾ç¤ºå¥å­ç¼–è¾‘è§†å›¾ï¼ˆè€Œééšè—è¿›åº¦ï¼‰
                            if (sentenceTexts.length > 1) {
                                selectedSentenceIndex = -1;
                                showSentenceEditorView();
                            } else {
                                hideProgressView();
                            }

                            // å°† base64 è½¬ä¸º blob URL
                            const binaryString = atob(data.audio);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            const blob = new Blob([bytes], { type: 'audio/wav' });
                            const audioUrl = URL.createObjectURL(blob);

                            // æ¢å¤æŒ‰é’®
                            btn.onclick = generate;
                            resolve({
                                audioUrl,
                                stats: data.stats,
                            });
                        }

                        if (data.error) {
                            eventSource.close();
                            currentEventSource = null;
                            isGenerating = false;
                            hideProgressView();
                            btn.onclick = generate;
                            reject(new Error(data.error));
                        }
                    } catch (e) {
                        console.error('Parse error:', e);
                    }
                };

                eventSource.onerror = (error) => {
                    eventSource.close();
                    currentEventSource = null;
                    isGenerating = false;
                    hideProgressView();
                    btn.onclick = generate;
                    reject(new Error(t('status.failed')));
                };
            }).catch((error) => {
                hideProgressView();
                statusEl.innerHTML = `<span class="text-red-600">${t('status.failed')}: ${error.message}</span>`;
                btn.disabled = false;
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
                return null;
            });
        }

        // POSTç‰ˆæœ¬çš„è¿›åº¦ç”Ÿæˆï¼ˆç”¨äºå…‹éš†ï¼Œéœ€è¦ä¸Šä¼ æ–‡ä»¶ï¼‰
        async function generateWithProgressPost(url, formData, btn, statusEl) {
            isGenerating = true;
            const text = document.getElementById('text-input').value.trim();
            const sentences = splitTextToSentences(text);
            showProgressView(sentences);

            try {
                const response = await fetch(url, { method: 'POST', body: formData });
                if (!response.ok) throw new Error('Request failed');

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let result = null;

                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="6" width="12" height="12"></rect></svg><span>${t('btn.stop')}</span>`;
                btn.disabled = false;
                btn.onclick = () => { reader.cancel(); stopGeneration(); };

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                if (data.started) {
                                    statusEl.textContent = `${t('status.generating')} 0/${data.total} ${t('stats.sentences')} (0%)`;
                                    updateSentenceProgress(0);
                                }
                                if (data.progress) {
                                    const { current, total, percent } = data.progress;
                                    btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="6" width="12" height="12"></rect></svg><span>${current}/${total} ${t('stats.sentences')} (${percent}%)</span>`;
                                    statusEl.textContent = `${t('status.generating')} ${current}/${total} ${t('stats.sentences')} (${percent}%)`;
                                    updateSentenceProgress(current);
                                }
                                if (data.done) {
                                    currentSubtitles = data.subtitles || null;
                                    // ä¿å­˜æ¯å¥éŸ³é¢‘å’Œæ–‡æœ¬
                                    if (data.sentence_audios) {
                                        sentenceAudios = data.sentence_audios;
                                        sentenceTexts = (data.subtitles || []).map(s => s.text);
                                        sentenceInstructs = sentenceTexts.map(() => lastGenerateParams?.instruct || '');
                                    }
                                    if (data.clone_prompt_id) {
                                        clonePromptId = data.clone_prompt_id;
                                        if (lastGenerateParams) lastGenerateParams.clone_prompt_id = data.clone_prompt_id;
                                    }
                                    saveSession(); // æŒä¹…åŒ–
                                    const binaryString = atob(data.audio);
                                    const bytes = new Uint8Array(binaryString.length);
                                    for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
                                    result = { audioUrl: URL.createObjectURL(new Blob([bytes], { type: 'audio/wav' })), stats: data.stats };
                                }
                                if (data.error) throw new Error(data.error);
                            } catch (e) { if (e.message !== 'Unexpected end of JSON input') throw e; }
                        }
                    }
                }

                isGenerating = false;
                // æ˜¾ç¤ºå¥å­ç¼–è¾‘è§†å›¾ï¼ˆè€Œééšè—è¿›åº¦ï¼‰
                if (sentenceTexts.length > 1) {
                    selectedSentenceIndex = -1;
                    showSentenceEditorView();
                } else {
                    hideProgressView();
                }
                btn.onclick = generate;
                return result;
            } catch (error) {
                isGenerating = false;
                hideProgressView();
                btn.onclick = generate;
                statusEl.innerHTML = `<span class="text-red-600">${t('status.failed')}: ${error.message}</span>`;
                btn.disabled = false;
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
                return null;
            }
        }

        async function generate() {
            const text = document.getElementById('text-input').value.trim();
            const btn = document.getElementById('generate-btn');
            const statusEl = document.getElementById('status-message');

            if (!text) {
                statusEl.textContent = t('status.enterText');
                return;
            }

            // éªŒè¯å…‹éš†æ¨¡å¼
            if (currentMode === 'clone' && !selectedVoiceId && !recordedBlob && !selectedFile) {
                statusEl.textContent = t('status.needAudio');
                return;
            }

            // éªŒè¯å£°éŸ³è®¾è®¡æ¨¡å¼
            if (currentMode === 'design') {
                const desc = document.getElementById('voice-desc').value.trim();
                if (!desc) {
                    statusEl.textContent = t('status.needDesc');
                    return;
                }
            }

            btn.disabled = true;
            btn.innerHTML = `<span class="spinner"></span><span>${t('status.generating')}</span>`;
            statusEl.textContent = '';

            // æ¸…é™¤ä¸Šæ¬¡çš„å¥å­ç¼–è¾‘çŠ¶æ€
            sentenceAudios = [];
            sentenceTexts = [];
            sentenceInstructs = [];
            decodedPcmCache = [];
            selectedSentenceIndex = -1;
            clonePromptId = null;
            undoStack = [];
            clearSession(); // æ¸…é™¤æŒä¹…åŒ–
            const hintEl = document.getElementById('sentence-view-hint');
            if (hintEl) hintEl.classList.add('hidden');

            // ç¡®ä¿æ¨¡å‹åŠ è½½
            const modelType = currentMode === 'preset' ? 'custom' : currentMode;
            const modelReady = await ensureModelLoaded(modelType);
            if (!modelReady) {
                btn.disabled = false;
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
                return;
            }

            try {
                let response;
                let stats = null;

                if (currentMode === 'preset') {
                    const speaker = document.getElementById('speaker').value;
                    const language = document.getElementById('language-preset').value;
                    const instruct = document.getElementById('instruct').value.trim();

                    lastGenerateParams = { mode: 'preset', speaker, language, instruct: instruct || null };

                    // ä½¿ç”¨åˆ†å¥è¿›åº¦ç”Ÿæˆ
                    const params = new URLSearchParams({ text, speaker, language });
                    if (instruct) params.append('instruct', instruct);

                    const result = await generateWithProgress(`/tts/progress?${params.toString()}`, btn, statusEl);
                    if (!result) return;

                    audioElement.src = result.audioUrl;
                    stats = result.stats;

                    // è·³è¿‡åé¢çš„ response å¤„ç†
                    loadWaveform();
                    audioElement.play();
                    document.getElementById('player-section').classList.remove('hidden');

                    if (stats) { lastStatsData = stats; renderStats(); }

                    statusEl.innerHTML = `<span class="text-green-600">${t('status.success')}</span>`;
                    document.getElementById('save-voice-section').classList.add('hidden');

                    btn.disabled = false;
                    btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
                    return;

                } else if (currentMode === 'clone') {
                    const language = document.getElementById('language-clone').value;
                    const refText = document.getElementById('ref-text').value.trim();

                    if (selectedVoiceId) {
                        lastGenerateParams = { mode: 'saved_voice', language, voice_id: selectedVoiceId };

                        // ä½¿ç”¨å£°éŸ³åº“çš„åˆ†å¥è¿›åº¦ç”Ÿæˆ
                        const params = new URLSearchParams({ text });
                        if (language) params.append('language', language);

                        const result = await generateWithProgress(`/voices/${selectedVoiceId}/tts/progress?${params.toString()}`, btn, statusEl);
                        if (!result) return;

                        audioElement.src = result.audioUrl;
                        stats = result.stats;

                        loadWaveform();
                        audioElement.play();
                        document.getElementById('player-section').classList.remove('hidden');

                        if (stats) { lastStatsData = stats; renderStats(); }

                        statusEl.innerHTML = `<span class="text-green-600">${t('status.success')}</span>`;
                        document.getElementById('save-voice-section').classList.add('hidden');

                        btn.disabled = false;
                        btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
                        return;
                    } else {
                        lastGenerateParams = { mode: 'clone', language, clone_prompt_id: null };

                        // ä½¿ç”¨å…‹éš†è¿›åº¦ç”Ÿæˆ
                        const audioFile = recordedBlob ? new File([recordedBlob], 'recording.webm', { type: 'audio/webm' }) : selectedFile;
                        const formData = new FormData();
                        formData.append('audio', audioFile);
                        formData.append('text', text);
                        formData.append('language', language);
                        formData.append('ref_text', refText);

                        const result = await generateWithProgressPost('/clone/progress', formData, btn, statusEl);
                        if (!result) return;

                        audioElement.src = result.audioUrl;
                        stats = result.stats;

                        loadWaveform();
                        audioElement.play();
                        document.getElementById('player-section').classList.remove('hidden');

                        if (stats) { lastStatsData = stats; renderStats(); }

                        statusEl.innerHTML = `<span class="text-green-600">${t('status.success')}</span>`;
                        document.getElementById('save-voice-section').classList.remove('hidden');

                        btn.disabled = false;
                        btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
                        return;
                    }

                } else if (currentMode === 'design') {
                    const language = document.getElementById('language-design').value;
                    const desc = document.getElementById('voice-desc').value.trim();

                    lastGenerateParams = { mode: 'design', language, instruct: desc };

                    // ä½¿ç”¨å£°éŸ³è®¾è®¡çš„åˆ†å¥è¿›åº¦ç”Ÿæˆ
                    const params = new URLSearchParams({ text, language, instruct: desc });

                    const result = await generateWithProgress(`/design/progress?${params.toString()}`, btn, statusEl);
                    if (!result) return;

                    audioElement.src = result.audioUrl;
                    stats = result.stats;

                    loadWaveform();
                    audioElement.play();
                    document.getElementById('player-section').classList.remove('hidden');

                    if (stats) { lastStatsData = stats; renderStats(); }

                    statusEl.innerHTML = `<span class="text-green-600">${t('status.success')}</span>`;
                    document.getElementById('save-voice-section').classList.add('hidden');

                    btn.disabled = false;
                    btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
                    return;
                }

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || t('status.failed'));
                }

                // æ’­æ”¾éŸ³é¢‘
                const blob = await response.blob();
                audioElement.src = URL.createObjectURL(blob);
                loadWaveform();
                audioElement.play();

                // æ˜¾ç¤ºæ’­æ”¾å™¨
                document.getElementById('player-section').classList.remove('hidden');

                // æ˜¾ç¤ºç»Ÿè®¡
                const charCount = response.headers.get('X-Char-Count');
                const elapsed = response.headers.get('X-Elapsed');
                const avgPerChar = response.headers.get('X-Avg-Per-Char');

                if (charCount && elapsed) {
                    lastStatsData = { char_count: charCount, sentence_count: null, elapsed, avg_per_char: avgPerChar };
                    renderStats();
                }

                statusEl.innerHTML = `<span class="text-green-600">${t('status.success')}</span>`;

                // å…‹éš†æ¨¡å¼æ˜¾ç¤ºä¿å­˜é€‰é¡¹ï¼ˆä»…éå£°éŸ³åº“ï¼‰
                if (currentMode === 'clone' && !selectedVoiceId) {
                    document.getElementById('save-voice-section').classList.remove('hidden');
                } else {
                    document.getElementById('save-voice-section').classList.add('hidden');
                }

            } catch (error) {
                statusEl.innerHTML = `<span class="text-red-600">${t('status.failed')}: ${error.message}</span>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>${t('btn.generate')}</span>`;
            }
        }

        async function ensureModelLoaded(modelType) {
            const statusEl = document.getElementById('status-message');

            try {
                const statusRes = await fetch('/model/status');
                const statusData = await statusRes.json();

                if (statusData.status[modelType] === 'loaded') {
                    return true;
                }

                if (statusData.status[modelType] === 'unloaded') {
                    statusEl.textContent = t('status.modelLoading');
                    await fetch(`/model/load/${modelType}`, { method: 'POST' });
                }

                // ç­‰å¾…åŠ è½½å®Œæˆ
                for (let i = 0; i < 120; i++) {
                    await new Promise(r => setTimeout(r, 1000));
                    const res = await fetch('/model/status');
                    const data = await res.json();
                    if (data.status[modelType] === 'loaded') {
                        statusEl.textContent = '';
                        return true;
                    }
                    if (data.status[modelType] === 'unloaded') {
                        statusEl.textContent = t('status.failed');
                        return false;
                    }
                }

                statusEl.textContent = t('status.failed');
                return false;

            } catch (error) {
                statusEl.textContent = t('status.failed') + ': ' + error.message;
                return false;
            }
        }

        // ===== éŸ³é¢‘æ’­æ”¾æ§åˆ¶ =====
        function togglePlay() {
            if (audioElement.paused) {
                audioElement.play();
            } else {
                audioElement.pause();
            }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function toggleDownloadMenu() {
            const menu = document.getElementById('download-menu');
            menu.classList.toggle('hidden');
        }

        // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­ä¸‹è½½èœå•
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('download-menu');
            const btn = document.getElementById('download-btn');
            if (menu && !menu.contains(e.target) && !btn.contains(e.target)) {
                menu.classList.add('hidden');
            }
        });

        async function downloadAudio(format = 'wav') {
            if (!audioElement.src) return;

            // å…³é—­èœå•
            document.getElementById('download-menu').classList.add('hidden');

            const timestamp = Date.now();

            if (format === 'wav') {
                const a = document.createElement('a');
                a.href = audioElement.src;
                a.download = `tts_${timestamp}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } else if (format === 'mp3') {
                try {
                    // æ˜¾ç¤ºè½¬æ¢ä¸­çŠ¶æ€
                    const btn = document.getElementById('download-btn');
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = '<span class="text-sm">è½¬æ¢ä¸­...</span>';
                    btn.disabled = true;

                    // è·å– WAV æ•°æ®
                    const response = await fetch(audioElement.src);
                    const arrayBuffer = await response.arrayBuffer();

                    // è§£æ WAV
                    const wavData = parseWav(arrayBuffer);

                    // è½¬æ¢ä¸º MP3
                    const mp3Blob = await convertToMp3(wavData);

                    // ä¸‹è½½
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(mp3Blob);
                    a.download = `tts_${timestamp}.mp3`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    // æ¢å¤æŒ‰é’®
                    btn.innerHTML = originalHTML;
                    btn.disabled = false;
                } catch (error) {
                    console.error('MP3 è½¬æ¢å¤±è´¥:', error);
                    alert('MP3 è½¬æ¢å¤±è´¥ï¼Œè¯·ä¸‹è½½ WAV æ ¼å¼');
                    const btn = document.getElementById('download-btn');
                    btn.innerHTML = originalHTML;
                    btn.disabled = false;
                }
            }
        }

        function downloadSubtitle(format) {
            if (!currentSubtitles || !currentSubtitles.length) {
                alert('æ²¡æœ‰å¯ç”¨çš„å­—å¹•æ•°æ®');
                return;
            }
            document.getElementById('download-menu').classList.add('hidden');
            const timestamp = Date.now();
            let content, filename;
            if (format === 'srt') {
                content = currentSubtitles.map((s, i) =>
                    `${i+1}\n${formatSrtTime(s.start)} --> ${formatSrtTime(s.end)}\n${s.text}\n`
                ).join('\n');
                filename = `tts_${timestamp}.srt`;
            } else {
                content = 'WEBVTT\n\n' + currentSubtitles.map((s, i) =>
                    `${i+1}\n${formatVttTime(s.start)} --> ${formatVttTime(s.end)}\n${s.text}\n`
                ).join('\n');
                filename = `tts_${timestamp}.vtt`;
            }
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
        }

        function formatSrtTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.round((seconds % 1) * 1000);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')},${String(ms).padStart(3,'0')}`;
        }

        function formatVttTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.round((seconds % 1) * 1000);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
        }

        // è§£æ WAV æ–‡ä»¶
        function parseWav(arrayBuffer) {
            const dataView = new DataView(arrayBuffer);

            // è¯»å– WAV å¤´ä¿¡æ¯
            const numChannels = dataView.getUint16(22, true);
            const sampleRate = dataView.getUint32(24, true);
            const bitsPerSample = dataView.getUint16(34, true);

            // æ‰¾åˆ° data chunk
            let offset = 12;
            while (offset < arrayBuffer.byteLength) {
                const chunkId = String.fromCharCode(
                    dataView.getUint8(offset),
                    dataView.getUint8(offset + 1),
                    dataView.getUint8(offset + 2),
                    dataView.getUint8(offset + 3)
                );
                const chunkSize = dataView.getUint32(offset + 4, true);

                if (chunkId === 'data') {
                    offset += 8;
                    break;
                }
                offset += 8 + chunkSize;
            }

            // è¯»å– PCM æ•°æ®
            const samples = new Int16Array(arrayBuffer, offset);

            return { samples, sampleRate, numChannels };
        }

        // è½¬æ¢ä¸º MP3
        function convertToMp3(wavData) {
            return new Promise((resolve) => {
                const { samples, sampleRate, numChannels } = wavData;

                const mp3encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, 128);
                const mp3Data = [];

                const blockSize = 1152;
                const numSamples = samples.length / numChannels;

                if (numChannels === 1) {
                    // å•å£°é“
                    for (let i = 0; i < numSamples; i += blockSize) {
                        const chunk = samples.subarray(i, Math.min(i + blockSize, numSamples));
                        const mp3buf = mp3encoder.encodeBuffer(chunk);
                        if (mp3buf.length > 0) {
                            mp3Data.push(mp3buf);
                        }
                    }
                } else {
                    // ç«‹ä½“å£° - åˆ†ç¦»å·¦å³å£°é“
                    const left = new Int16Array(numSamples);
                    const right = new Int16Array(numSamples);
                    for (let i = 0; i < numSamples; i++) {
                        left[i] = samples[i * 2];
                        right[i] = samples[i * 2 + 1];
                    }

                    for (let i = 0; i < numSamples; i += blockSize) {
                        const leftChunk = left.subarray(i, Math.min(i + blockSize, numSamples));
                        const rightChunk = right.subarray(i, Math.min(i + blockSize, numSamples));
                        const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
                        if (mp3buf.length > 0) {
                            mp3Data.push(mp3buf);
                        }
                    }
                }

                // å®Œæˆç¼–ç 
                const end = mp3encoder.flush();
                if (end.length > 0) {
                    mp3Data.push(end);
                }

                resolve(new Blob(mp3Data, { type: 'audio/mp3' }));
            });
        }

        let playingSentenceIndex = -1;

        function updatePlaybackHighlight(currentTime) {
            if (!currentSubtitles || !currentSubtitles.length) return;

            // æ‰¾åˆ°å½“å‰æ’­æ”¾çš„å¥å­
            let newIndex = -1;
            for (let i = 0; i < currentSubtitles.length; i++) {
                const sub = currentSubtitles[i];
                if (currentTime >= sub.start && currentTime < sub.end) {
                    newIndex = i;
                    break;
                }
            }

            if (newIndex === playingSentenceIndex) return;
            playingSentenceIndex = newIndex;

            // æ£€æŸ¥å¥å­ç¼–è¾‘è§†å›¾æ˜¯å¦å¯è§
            const progressView = document.getElementById('progress-view');
            if (progressView.classList.contains('hidden')) return;
            const items = progressView.querySelectorAll('.sentence-editor-item');
            if (!items.length) return;

            items.forEach((el, i) => {
                // è·³è¿‡æ­£åœ¨ç¼–è¾‘çš„å¥å­
                const textEl = el.querySelector('[contenteditable="true"]');
                if (textEl) return;

                el.classList.remove('playing', 'played');
                if (i === newIndex) {
                    el.classList.add('playing');
                } else if (newIndex >= 0 && i < newIndex) {
                    el.classList.add('played');
                }
            });

            // è‡ªåŠ¨æ»šåŠ¨åˆ°å½“å‰å¥å­
            if (newIndex >= 0 && items[newIndex]) {
                items[newIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }

        function clearPlaybackHighlight() {
            playingSentenceIndex = -1;
            document.querySelectorAll('.sentence-editor-item.playing, .sentence-editor-item.played').forEach(el => {
                el.classList.remove('playing', 'played');
            });
        }

        audioElement.addEventListener('timeupdate', () => {
            if (!wavesurfer) {
                document.getElementById('current-time').textContent = formatTime(audioElement.currentTime);
                updatePlaybackHighlight(audioElement.currentTime);
            }
        });

        audioElement.addEventListener('loadedmetadata', () => {
            document.getElementById('duration').textContent = formatTime(audioElement.duration);
        });

        audioElement.addEventListener('play', () => {
            document.getElementById('play-icon').innerHTML = '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>';
            updatePlaybackHighlight(audioElement.currentTime);
        });

        audioElement.addEventListener('pause', () => {
            document.getElementById('play-icon').innerHTML = '<polygon points="5 3 19 12 5 21 5 3"></polygon>';
            clearPlaybackHighlight();
        });

        audioElement.addEventListener('ended', () => {
            document.getElementById('play-icon').innerHTML = '<polygon points="5 3 19 12 5 21 5 3"></polygon>';
            clearPlaybackHighlight();
            if (_sentencePreviewEndHandler) {
                audioElement.removeEventListener('timeupdate', _sentencePreviewEndHandler);
                _sentencePreviewEndHandler = null;
                sentencePreviewIndex = -1;
                showSentenceEditorView();
            }
        });

        // ===== é”®ç›˜å¿«æ·é”® =====
        function isSentenceEditorVisible() {
            const pv = document.getElementById('progress-view');
            return pv && !pv.classList.contains('hidden') && pv.querySelector('.sentence-editor-list');
        }

        function isEditingText() {
            const el = document.activeElement;
            if (!el) return false;
            if (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') return true;
            if (el.contentEditable === 'true') return true;
            return false;
        }

        document.addEventListener('keydown', (e) => {
            // Ctrl+Z / Cmd+Z: æ’¤é”€ï¼ˆå…¨å±€ï¼Œä¸åœ¨è¾“å…¥æ¡†æ—¶ï¼‰
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !isEditingText()) {
                if (isSentenceEditorVisible() && undoStack.length > 0) {
                    e.preventDefault();
                    undoRegenerate();
                    return;
                }
            }

            // ä»¥ä¸‹å¿«æ·é”®ä»…åœ¨å¥å­ç¼–è¾‘è§†å›¾å¯è§æ—¶ç”Ÿæ•ˆ
            if (!isSentenceEditorVisible()) return;

            // æ­£åœ¨ç¼–è¾‘å¥å­æ–‡æœ¬æ—¶ï¼Œåªå¤„ç† Esc
            if (isEditingText()) {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    finishEditing();
                }
                return;
            }

            switch (e.key) {
                case ' ':  // ç©ºæ ¼: æ’­æ”¾/æš‚åœ
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowUp':  // â†‘: ä¸Šä¸€å¥
                    e.preventDefault();
                    if (selectedSentenceIndex > 0) {
                        selectedSentenceIndex--;
                    } else if (selectedSentenceIndex === -1 && sentenceTexts.length > 0) {
                        selectedSentenceIndex = 0;
                    }
                    document.querySelectorAll('.sentence-editor-item').forEach((el, i) => {
                        el.classList.toggle('selected', i === selectedSentenceIndex);
                    });
                    document.getElementById(`sent-item-${selectedSentenceIndex}`)?.scrollIntoView({ block: 'nearest' });
                    break;
                case 'ArrowDown':  // â†“: ä¸‹ä¸€å¥
                    e.preventDefault();
                    if (selectedSentenceIndex < sentenceTexts.length - 1) {
                        selectedSentenceIndex++;
                    } else if (selectedSentenceIndex === -1 && sentenceTexts.length > 0) {
                        selectedSentenceIndex = 0;
                    }
                    document.querySelectorAll('.sentence-editor-item').forEach((el, i) => {
                        el.classList.toggle('selected', i === selectedSentenceIndex);
                    });
                    document.getElementById(`sent-item-${selectedSentenceIndex}`)?.scrollIntoView({ block: 'nearest' });
                    break;
                case 'Enter':  // Enter: é‡æ–°ç”Ÿæˆé€‰ä¸­å¥
                    if (selectedSentenceIndex >= 0) {
                        e.preventDefault();
                        regenerateSentence(selectedSentenceIndex);
                    }
                    break;
                case 'Escape':  // Esc: å–æ¶ˆé€‰ä¸­
                    e.preventDefault();
                    selectedSentenceIndex = -1;
                    document.querySelectorAll('.sentence-editor-item').forEach(el => el.classList.remove('selected'));
                    break;
                case 'p':  // P: è¯•å¬é€‰ä¸­å¥
                    if (selectedSentenceIndex >= 0) {
                        e.preventDefault();
                        previewSentenceAudio(selectedSentenceIndex);
                    }
                    break;
                case 'Delete':  // Delete: åˆ é™¤é€‰ä¸­å¥
                case 'Backspace':
                    if (selectedSentenceIndex >= 0) {
                        e.preventDefault();
                        deleteSentence(selectedSentenceIndex);
                    }
                    break;
            }
        });

        // ===== åˆå§‹åŒ– =====
        document.addEventListener('DOMContentLoaded', () => {
            currentLang = localStorage.getItem('lang') || 'zh';
            updateI18n();
            loadSavedVoices();
            updateCharCount();
            restoreSession(); // æ¢å¤ä¸Šæ¬¡ä¼šè¯
        });
    </script>
</body>
</html>
